<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Gabriel N√ºtzi, gabriel.nuetzi@sdsc.ethz.ch">
  <title>Rust Workshop ü¶Ä</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@5.1.0/dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@5.1.0/dist/reveal.css">
  <style>
    .reveal .sourceCode {  /* see #7635 */
      overflow: visible;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>

  <link rel="stylesheet" href="dist/theme/company.css" />
  <link rel="stylesheet" href="plugin/highlight/styles/railscasts.css" />

  <script>
      // If decktape export we need to load some other css
      // Emoji-Convertion
      if (window.location.search.match(/decktape/gi)) {
        let link = document.createElement("link")
        link.rel = "stylesheet"
        link.type = "text/css"
        link.href = "css/print/decktape.css"
        document.getElementsByTagName("head")[0].appendChild(link)
      }
    </script>

  <link rel="stylesheet" href="presentations/presentation-1/css/custom.css"/>
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Rust Workshop ü¶Ä</h1>
  <h3 class="subtitle"><p>Part 2: Create Engineering<br></p></h3>
  <p class="author"><strong>Gabriel N√ºtzi</strong>, <a
href="mailto:gabriel.nuetzi@sdsc.ethz.ch">gabriel.nuetzi@sdsc.ethz.ch</a></p>
  <p class="date"><p>February 16, 2025, <a
href="https://sdsc-ordes.github.io/technical-presentation/gh-pages/rust-workshop/part-1"
target="_blank">Part 1</a></p></p>
</section>

<section id="help" class="title-slide slide level1">
<h1>Help</h1>
<p>How to use these slides:</p>
<ul>
<li><kbd>S</kbd>: See the speaker notes.</li>
<li><kbd>Esc</kbd>: See all slides and jump around.</li>
<li><kbd>Space</kbd>: Go forward.</li>
<li><kbd>Shift</kbd> + <kbd>Space</kbd>: Go backward.</li>
</ul>
</section>

<section id="acknowledgment" class="title-slide slide level1">
<h1>Acknowledgment</h1>
<p>Thanks to the following contributors who fixed typos and
mistakes:</p>
<ul>
<li><p>The ORDES Team at SDSC, who helped me fixing typos &amp;
bugs.</p></li>
<li><p>Gerry Br√§unlich, Michael Kefeder &amp; Stefan T√ºx who allowed me
to attend the <a href="https://rustfest.ch" target="_blank">Rust
Fest</a> and pointing me to interesting teaching material.</p></li>
</ul>
<p>External:</p>
<ul>
<li><a href="https://github.com/trifectatechfoundation/teach-rs"
target="_blank">TeachRs</a>: Exercises and course material.</li>
<li><a href="https://google.github.io/comprehensive-rust"
target="_blank">Comprehensive Rust</a>: Inspiration.</li>
</ul>
<!-- markdownlint-disable-file MD034 MD033 MD001 MD024 MD026-->
</section>

<section>
<section id="why-rust" class="title-slide slide level1">
<h1>Why Rust</h1>

</section>
<section id="what-the-heck-is-rust" class="slide level2">
<h2>What the Heck is Rust ü¶Ä</h2>
<h3 id="a-multi-paradigm-language">A Multi-Paradigm Language</h3>
<ul>
<li>procedural like Python, i.e.¬†<em>functions</em> Û∞äï, <em>loops</em> Û∞ëô,
‚Ä¶</li>
<li>functional aspects, i.e.¬†<em>iterators</em> üèÉ, <em>lambdas</em> Û∞°±
‚Ä¶</li>
<li>object-oriented aspects but unlike Python (Ó™ú its better ‚ù§Ô∏è)</li>
</ul>
</section>
<section id="what-the-heck-is-rust-1" class="slide level2">
<h2>What the Heck is Rust ü¶Ä</h2>
<h4 id="a-compiled-language-unlike-python">A <strong>Compiled</strong>
Language Unlike Python</h4>
<ul>
<li><p>The Rust compiler <code>rustc</code> ü¶Ä will convert your code to
machine-code ‚öôÔ∏è. <br> Python is an interpreter.</p></li>
<li><p>It has a <strong>strong type system</strong> (<a
href="TODO">algebraic types</a>: sum types, product types).</p></li>
<li><p>It was invented in 2009 by Mozilla (Firefox) - Rust Foundation as
the driver today.</p></li>
</ul>
<p>Note: 10% of Firefox is in Rust for good reasons you will realize in
the following.</p>
</section>
<section id="benefits-you-get-on-the-journey" class="slide level2">
<h2>Benefits You Get on the ü¶Ä Journey</h2>
<p>A few selling points for <code>python</code> programmers.</p>
</section>
<section id="come-on-show-me-syntax" class="slide level2">
<h2>Come on üê® show me syntax!</h2>
<p>The syntax* is similar and as easy to read as in Python.</p>
<!-- prettier-ignore-start -->
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust"><code>#[derive(Debug)]
struct Apple {
  name: String
}

fn grow() -&gt; Vec&lt;Apple&gt; {

  let apples = vec![Apple{name: &quot;a&quot;.to_string()},
                    Apple{name: &quot;b&quot;.to_string()}];

  for b in &amp;apples {
    println!(&quot;Apple: {b:?}&quot;);
  }

  apples
}</code></pre>
</div><div class="column" style="width:50%;">
<pre class="python"><code>@dataclass
class Apple:
  name: str

def grow() -&gt; List[Apple]:

  apples = [Apple(&quot;a&quot;),
            Apple(&quot;b&quot;)]

  for b in apples:
    print(f&quot;Apple: {b.name}&quot;)


  return apples</code></pre>
</div>
</div>
<!-- prettier-ignore-end -->
<p>*: 80% you will encounter is very readable (except macros etc.).</p>
</section>
<section id="but-why" class="slide level2">
<h2>But Why?</h2>
<h3>
More reasons why you should learn a <em class="emph">compiled,
statically typed</em> </span>language‚Ä¶
</h3>
</section>
<section class="slide level2">

<h3 id="what-rust-promises">What Rust Promises ü§ö</h3>
<div>
<div class="center-content">
<ol type="1">
<li class="fragment"><strong>Pedal to the metal</strong></li>
<li class="fragment"><strong>Comes with a warranty</strong></li>
<li class="fragment"><strong>Beautiful code</strong></li>
<li class="fragment"><strong>Rust is practical</strong></li>
</ol>
</div>
</div>
</section>
<section id="pedal-to-the-metal" class="slide level2">
<h2>Pedal to The Metal</h2>
<div>
<ul>
<li class="fragment"><p>Compiled language, not interpreted.</p></li>
<li class="fragment"><p>State-of-the-art machine-code generation using
LLVM.</p></li>
<li class="fragment"><p>No garbage collector (GC) getting in the way of
execution.</p>
<pre class="python" data-line-numbers=""><code>def run():
  d = { &quot;a&quot;:1, &quot;b&quot;:2 } # Memory is allocated on the heap.

run()</code></pre>
<p><strong>Question:</strong> Does the memory of <code>d</code> still
exist after <code>run()</code>?</p>
<p><span class="fragment">Ó™ú We don‚Äôt know ü§∑</span></p></li>
<li class="fragment"><p>Usable in embedded devices, operating systems
and demanding websites.</p></li>
</ul>
</div>
<aside class="notes">
<p>Explain what a garbage collector does explain what the heap/stack are
later.</p>
</aside>
</section>
<section id="rust-comes-with-a-warranty" class="slide level2">
<h2>Rust Comes with a Warranty</h2>
<div>
<ul>
<li class="fragment"><p>Strong type system helps prevent silly bugs
üêû:</p>
<pre class="python"><code>def concat(numbers: List[str]) -&gt; str:
  return &quot;-&quot;.join(numbers)

concat([&quot;1&quot;, &quot;2&quot;, &quot;30&quot;, 4, &quot;5&quot;, &quot;7&quot;, &quot;10&quot;])</code></pre></li>
<li class="fragment"><p>Explicit errors instead of exceptions ‚ùó(<a
href="TODO">later</a>):</p>
<pre class="python"><code>def main():
  file_count = get_number_of_files()
  if file_count is None:
    print(&quot;Could not determine file count.&quot;)</code></pre>
<p><span class="fragment"><strong>Question:</strong> Is this error
handling correct if: <br> <code
class="python">get_number_of_files = lambda: int(sys.argv[0])</code></span></p></li>
</ul>
</div>
</section>
<section id="rust-comes-with-a-warranty-1" class="slide level2">
<h2>Rust Comes with a Warranty</h2>
<div>
<ul>
<li class="fragment"><p><strong>Ownership Model</strong>: Type system
tracks lifetime of objects.</p>
<ul>
<li class="fragment">No more exceptions about accessing
<code>None</code>.</li>
<li class="fragment">You know who owns an objects
(variable/memory).</li>
</ul></li>
<li class="fragment"><p>Programs don‚Äôt trash your system
accidentally</p>
<ul>
<li class="fragment">Warranty <em>can</em> be voided
(<code>unsafe</code>).</li>
</ul></li>
</ul>
</div>
<aside class="notes">
<p>Throws two exceptions: <code>ValueError</code> and
<code>TypeError</code>. <strong>Ownership Model</strong>: Strict rules
on how memory is managed and shared Ó™ú Safe Code ü¶∫. (<small>Note:
variables bind to memory</small>)</p>
</aside>
</section>
<section id="rust-comes-with-a-warranty-2" class="slide level2">
<h2>Rust Comes with a Warranty</h2>
<p><strong>Experience: <span class="emph"><em>‚Äú‚ô•Ô∏è If it compiles, it is
more often correct. ‚ô•Ô∏è‚Äù</em></span></strong></p>
<div>
<ul>
<li class="fragment"><p>Enables <a
href="https://www.youtube.com/watch?v=Kdpfhj3VM04"
target="_blank">compiler driven development</a>.</p></li>
<li class="fragment"><p>100% code coverage:</p>
<div class="columns">
<div class="column fragment" style="width:50%;">
<p>Python:</p>
<pre class="python smaller-code"><code>def get_float(num: str | float) -&gt; float:
  match (num):
      case str(num):
          return float(num)</code></pre>
<p><em>You trust <code>mypy</code> which is not enforced at
runtime.</em></p>
</div><div class="column fragment" style="width:50%;">
<p>Rust:</p>
<pre class="rust smaller-code"><code>enum StrOrFloat {
  MyStr(String),
  MyFloat(f64),
}

fn get_float(n: StrOrFloat) -&gt; f64 {
    match n {
        StrOrFloat::MyFloat(x) =&gt; x,
    }
}</code></pre>
</div>
</div></li>
</ul>
</div>
<aside class="notes">
<p>Rust allows quite a different programming experience. It‚Äôs called
<strong>compiler driven development</strong> (e.g.¬†guard your business
logic with the type-system at your hand, e.g.¬†type-state pattern. I
explain threads later. Certain statements allow <code>rustc</code> to
check that you covered all cases. Python: With power comes
responsibility. Python is very dynamic, but this duck-typing and
non-strictness results often in a mess.</p>
</aside>
</section>
<section id="rust-comes-with-a-warranty-3" class="slide level2">
<h2>Rust Comes with a Warranty</h2>
<p><strong>Experience: <span class="emph"><em>‚Äú‚ô•Ô∏è If it compiles, it is
more often correct. ‚ô•Ô∏è‚Äù</em></span></strong></p>
<ul>
<li>No invalid syntax.</li>
<li>Guaranteed thread safety.</li>
<li>Model your business logic with <code>struct</code> and
<code>enums</code>.</li>
</ul>
</section>
<section id="performance" class="slide level2">
<h2>Performance</h2>
<div>
<ul>
<li class="fragment"><p>Rust is <strong>fast</strong> üöÄ. Comparable to
C++/C, faster than <code>go</code>.</p>
<ul>
<li class="fragment"><em>Python is slow, that‚Äôs why most libraries
outsource to C or <a href="https://github.com/PyO3/pyo3"
target="_blank"><code>Rust</code></a>.</em></li>
</ul></li>
<li class="fragment"><p>Rust is <strong>concurrent</strong> ‚áâ by design
<em>(safe-guarded by the ownership model)</em>.</p>
<ul>
<li class="fragment">Python has an <a
href="https://realpython.com/python-gil/" target="_blank">interpreter
lock (GIL)</a> which prohibits proper threading (<a
href="https://www.lesinskis.com/python-GIL-removal.html"
target="_blank">it gets removed</a>).</li>
</ul></li>
</ul>
</div>
</section>
<section id="why-should-learn-rust" class="slide level2">
<h2>Why Should ü´µ Learn Rust?</h2>
<div>
<ul>
<li class="fragment"><p>Learning a new language teaches you new
tricks:</p>
<ul>
<li class="fragment">You will also write better code (also in
Python)!</li>
</ul></li>
<li class="fragment"><p>Rust is a young, but a quickly growing
platform:</p>
<ul>
<li class="fragment">You can help shape its future.</li>
<li class="fragment">Demand for Rust programmers will increase!</li>
</ul></li>
</ul>
</div>
<!-- markdownlint-disable-file MD034 MD033 MD001 MD024 MD026-->
</section></section>
<section>
<section id="creating-a-nice-api" class="title-slide slide level1">
<h1>Creating a Nice API</h1>
<aside class="notes">
<pre><code>A big part of developing a larger project is to define a nice, readable API that clarifies intent. Let&#39;s have a look at some guidelines Rust specifies in order to make crates useful for others or even future you.</code></pre>
</aside>
</section>
<section id="rust-api-guidelines" class="slide level2">
<h2>Rust API Guidelines</h2>
<div class="columns">
<div class="column" style="width:50%;">
<ul>
<li>Defined by the Rust project</li>
<li><a href="https://rust-lang.github.io/api-guidelines/checklist.html"
target="_blank">Checklist available</a> (Link in exercises).</li>
</ul>
<p><strong>Read the checklist, use it!</strong></p>
</div><div class="column" style="width:50%;">
<p><span class="image placeholder"
data-original-image-src="presentations/part-2/assets/images/A2-rust-guideline.png"
data-original-image-title=""></span></p>
</div>
</div>
<aside class="notes">
<p>To improve consistency between crates, Rust defines a whole lot of
guidelines. There‚Äôs even a checklist available. In this section, we‚Äôll
focus on some guidelines. However, make sure to use the checklist for
all code you write in exercises!</p>
</aside>
</section>
<section id="general-recommendations" class="slide level2">
<h2>General Recommendations</h2>
<p>Make your API</p>
<ul>
<li>Unsurprising</li>
<li>Flexible</li>
<li>Obvious</li>
</ul>
<p><strong>Next up: Some low-hanging fruits</strong></p>
<aside class="notes">
<p>In general, you want to make your API unsurprising, flexible and
obvious.</p>
<ul>
<li>An unsurprising API uses patterns that are broadly used, allowing
the user to guess how the interface is structured.</li>
<li>Flexible APIs are suitable for many applications, and only as
restrictive as they inherently need to be.</li>
<li>Make your API obvious to enable users to quickly understand rules of
your library.</li>
</ul>
</aside>
</section>
<section id="make-your-api---unsurprising" class="slide level2">
<h2>Make your API - Unsurprising</h2>
<aside class="notes">
<p>So, how to make your API unsurprising?</p>
</aside>
</section>
<section id="naming-your-methods" class="slide level2">
<h2>Naming your Methods</h2>
<div class="columns">
<div class="column" style="width:%;">
<pre class="rust" data-line-numbers="|7-10|12-15"><code>pub struct S {
  first: First,
  second: Second,
}

impl S {
  // Not get_first.
  pub fn first(&amp;self) -&gt; &amp;First {
      &amp;self.first
  }

  // Not get_first_mut, get_mut_first, or mut_first.
  pub fn first_mut(&amp;mut self) -&gt; &amp;mut First {
      &amp;mut self.first
  }
}</code></pre>
</div><div class="column" style="width:50%;">
<p>Other example: conversion methods <code>as_</code>, <code>to_</code>,
<code>into_</code>, name depends on:</p>
<ul>
<li>Runtime cost</li>
<li>Owned ‚áî Borrowed</li>
</ul>
</div>
</div>
<aside class="notes">
<p>An easy way of making your API unsurprising is by adhering to naming
conventions.</p>
<ul>
<li>For example, the guidelines specify a naming convention for getters.
Note that getter names do not start with <code>get</code>, and that the
mutable getter ends with <code>mut</code>.</li>
<li>Another example is the way conversion methods are named, based on
their runtime cost and whether the conversion is between references,
owned values, or from reference to owned and vice-versa.</li>
</ul>
</aside>
</section>
<section id="implementderive-common-traits" class="slide level2">
<h2>Implement/Derive Common Traits</h2>
<p><em>As long as it makes sense</em> public types should implement:</p>
<div class="columns">
<div class="column" style="width:50%;">
<ul>
<li><code>Copy</code></li>
<li><code>Clone</code></li>
<li><code>Eq</code></li>
<li><code>PartialEq</code></li>
<li><code>Ord</code></li>
<li><code>PartialOrd</code></li>
</ul>
</div><div class="column" style="width:50%;">
<ul>
<li><code>Hash</code></li>
<li><code>Debug</code></li>
<li><code>Display</code></li>
<li><code>Default</code></li>
<li><code>serde::Serialize</code></li>
<li><code>serde::Deserialize</code></li>
</ul>
</div>
</div>
<aside class="notes">
<p>Here‚Äôs a list of common traits to implement or derive automatically,
making your types more useful to others.</p>
</aside>
</section>
<section id="make-your-api---flexible" class="slide level2">
<h2>Make your API - Flexible</h2>
<aside class="notes">
<p>Now, let‚Äôs take a look at some ways to make your API flexible</p>
</aside>
</section>
<section id="use-generics" class="slide level2">
<h2>Use Generics</h2>
<pre class="rust" data-line-numbers="|1-3|5-9"><code>pub fn add(x: u32, y: u32) -&gt; u32 {
    x + y
}

/// Adds two values that implement the `Add` trait,
/// returning the specified output
pub fn add_generic&lt;O, T: std::ops::Add&lt;Output = O&gt;&gt;(x: T, y: T) -&gt; O {
    x + y
}</code></pre>
<aside class="notes">
<p>An great way to lift restrictions on your API is to write your
functions in terms of traits. That is, use generics to describe what
exactly is needed to perform a certain action.</p>
<ul>
<li>In this example, the first function only accepts <code>u32</code>,
whereas there are many other numeric types for which addition makes
sense.</li>
<li>The second example, though, accepts anything for which the
<code>Add</code> trait is implemented. It is even generic over the
addition output.</li>
</ul>
</aside>
</section>
<section id="accept-borrowed-data-if-possible" class="slide level2">
<h2>Accept Borrowed Data (if possible)</h2>
<ul>
<li>User decides whether calling function should own the data.</li>
<li>Avoids unnecessary moves.</li>
<li>Exception: <strong>non-large</strong> array <code>Copy</code>
types</li>
</ul>
<pre class="rust" data-line-numbers="|6-9|11-14"><code>/// Some very large struct
pub struct LargeStruct {
    data: [u8; 4096],
}

/// Takes owned [LargeStruct] and returns it when done. This is costly!
pub fn manipulate_large_struct(mut large: LargeStruct) -&gt; LargeStruct {
    todo!()
}

/// Just borrows [LargeStruct]. This is cheap!
pub fn manipulate_large_struct_borrowed(large: &amp;mut LargeStruct) {
    todo!()
}</code></pre>
<aside class="notes">
<p>An even neater way to make your API flexible is by allowing the user
to decide whether the data that is passed to your function is owned by
the calling function or not. This is done by accepting borrowed data
wherever possible. This avoids unnecessary moves. An exception to this
guideline is for non-large <code>Copy</code> types, as they are cheap to
clone.</p>
<ul>
<li>The first function in the example moves the <code>LargeStruct</code>
into its own scope, and then moves it out again. That may be costly and
requires ownership from calling function!</li>
<li>The second function merely borrows the <code>LargeStruct</code>,
which is cheap and flexible.</li>
</ul>
</aside>
</section>
<section id="make-your-api---obvious" class="slide level2">
<h2>Make your API - Obvious</h2>
<aside class="notes">
<p>Lastly, we‚Äôll make our APIs obvious</p>
</aside>
</section>
<section id="write-rustdoc" class="slide level2">
<h2>Write Rustdoc</h2>
<div class="columns">
<div class="column" style="width:60%;">
<ul>
<li>Use 3 forward-slashes to start a doc comment.</li>
<li>You can add code examples, too.</li>
<li>To open docs in your browser: <code>cargo doc --open</code></li>
</ul>
<pre class="rust"><code>/// A well-documented struct.
/// ```rust
/// # // lines starting with a `#` are hidden
/// # use ex_b::MyDocumentedStruct;
/// let my_struct = MyDocumentedStruct {
///     field: 1,
/// };
/// println!(&quot;{:?}&quot;, my_struct.field);
/// ```
pub struct MyDocumentedStruct {
    /// A field with data
    pub field: u32,
}</code></pre>
</div><div class="column" style="width:40%;">
<p><img
data-src="presentations/part-2/assets/images/convert/presentations/part-2/assets/images/A2-rustdoc.png" /></p>
</div>
</div>
<aside class="notes">
<p>Lots of respect for authors of good documentation! If you find
writing documentation hard, keep in mind that you may be writing this
for your future self.</p>
<ul>
<li>A doc comment in Rust starts with three forward-slashes</li>
<li>You can add code examples, which can even be tested automatically to
ensure they‚Äôre not out of date after a refactor.</li>
<li>Using <code>cargo doc --open</code>, you can render documentation
locally and open it in your browser. Here‚Äôs how it looks: [see
image]</li>
</ul>
</aside>
</section>
<section id="include-examples" class="slide level2">
<h2>Include Examples</h2>
<p>Create examples to show users how to use your library</p>
<pre class="bash" data-line-numbers="all"><code>tree
.
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ examples
‚îÇ   ‚îî‚îÄ‚îÄ say_hello.rs
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ lib.rs</code></pre>
<pre class="bash"><code>cargo run --example say_hello
...
Hello, henkdieter!</code></pre>
<aside class="notes">
<ul>
<li>If you‚Äôre writing a library, adding a couple of examples helps your
users get started. In fact, many libraries are accompanied with examples
defined in their Git repositories.</li>
<li>Run examples with the <code>--example</code> option, specifying the
binary</li>
</ul>
</aside>
</section>
<section id="url-example" class="slide level2">
<h2>Use Semantic Typing (1)</h2>
<p>Make the type system work for you!</p>
<pre class="rust" data-line-numbers="all|1-2|7-8"><code>/// Fetch a page from passed URL
fn load_page(url: &amp;str) -&gt; String {
    todo!(&quot;Fetch&quot;);
}

fn main() {
  let page = load_page(&quot;https://teach-rs.tweede.golf&quot;);
  let crab = load_page(&quot;ü¶Ä&quot;); // Ouch!
}</code></pre>
<p><em><code>&amp;str</code> is not restrictive enough: not all
<code>&amp;str</code> represent correct URLs</em></p>
<aside class="notes">
<p>Rusts type system is awesome. Use it to you advantage by embedding
semantics into your types.</p>
<ul>
<li>As an example, the <code>load_page</code> function takes a string
slice, indicating the URL of the page that it should load.</li>
<li>At the call site of load_page, it‚Äôs unclear what a page even is
(memory page? remote content?)</li>
<li><code>load_page</code> accepts all strings, even strings that do not
represent valid URLs</li>
</ul>
</aside>
</section>
<section id="use-semantic-typing-2" class="slide level2">
<h2>Use Semantic Typing (2)</h2>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust"
data-line-numbers="all|1-3,14-16|5-12,22-24|18-20|all"><code>struct Url&lt;&#39;u&gt; {
  url: &amp;&#39;u str,
}

impl&lt;&#39;u&gt; Url&lt;&#39;u&gt; {
  fn new(url: &amp;&#39;u str) -&gt; Self {
    if !valid(url) {
      panic!(&quot;URL invalid: {}&quot;, url);
    }
    Self { url }
  }
}
fn valid(url: &amp;str) -&gt; bool {
  url != &quot;ü¶Ä&quot;
}</code></pre>
</div><div class="column" style="width:50%;">
<pre class="rust"><code>fn load_page(remote: Url) -&gt; String {
    todo!(&quot;load it&quot;);
}
fn main() {
    // Not good
    let c = load_page(Url::new(&quot;ü¶Ä&quot;));
}</code></pre>
<pre class="txt"><code>thread &#39;main&#39; panicked at
&#39;URL invalid: ü¶Ä&#39;, src/main.rs:11:7
note: run with `RUST_BACKTRACE=1` ...</code></pre>
<div>
<ul>
<li class="fragment">Clear intent.</li>
<li class="fragment">Validate inputs: security!</li>
<li class="fragment"><strong>Use the <a href="https://lib.rs/url"
target="_blank"><code>url</code></a> crate.</strong></li>
</ul>
</div>
</div>
</div>
<aside class="notes">
<ul>
<li>The <code>Url</code> struct defined here, wraps a string slice, but
has a name that clarifies intent at the call site</li>
<li>what‚Äôs more, the <code>Url</code> struct can only be instantiated
with strings that represent valid URLs</li>
</ul>
</aside>
</section>
<section id="use-clippy-and-rustfmt---all-time" class="slide level2">
<h2>Use Clippy and Rustfmt - All Time!</h2>
<pre class="bash"><code>cargo clippy
cargo fmt</code></pre>
<p>Use the state-of-the-art <a
href="https://github.com/sdsc-ordes/repository-template"
target="_blank">repository-template <code>rust</code></a>.</p>
<aside class="notes">
<p>Use Clippy and Rustfmt to help adhering to the guidelines.</p>
</aside>
</section></section>
<section>
<section id="design-patterns-in-rust" class="title-slide slide level1">
<h1>Design Patterns in Rust</h1>

</section>
<section id="why-design-patterns" class="slide level2">
<h2>Why Design Patterns?</h2>
<ul>
<li>Common problems call for common, tried an tested solutions.</li>
<li>Make crate architecture more clear.</li>
<li>Speed up development.</li>
<li>Rust does some patterns ever-so-slightly differently.</li>
</ul>
<p><em>Learning common Rust patterns makes understanding new code
easier</em></p>
</section>
<section id="what-do-we-cover" class="slide level2">
<h2>What Do We Cover?</h2>
<pre class="rust"><code>const PATTERNS: &amp;[Pattern] = &amp;[
    Pattern::new(&quot;Newtype&quot;),
    Pattern::new(&quot;RAII with guards&quot;),
    Pattern::new(&quot;Typestate&quot;),
    Pattern::new(&quot;Strategy&quot;),
];
fn main() {
    for pattern in PATTERNS {
        pattern.introduce();
        pattern.show_example();
        pattern.when_to_use();
    }
}</code></pre>
</section>
<section id="the-newtype-pattern" class="slide level2">
<h2>1. The Newtype Pattern</h2>
<p>A small but useful pattern.</p>
</section>
<section id="newtype-introduction" class="slide level2">
<h2>Newtype: Introduction</h2>
<h4 id="wrap-an-external-type-in-a-new-local-type">Wrap an external type
in a new local type</h4>
<pre class="rust"><code>pub struct Imei(String)</code></pre>
<p>That‚Äôs it!</p>
</section>
<section id="newtype-example" class="slide level2">
<h2>Newtype: Example</h2>
<pre class="rust" style="font-size:14pt;"><code>pub enum ValidateImeiError { /* - snip - */}
pub struct Imei(String);

impl Imei {
  fn validate(imei: &amp;str) -&gt; Result&lt;(), ValidateImeiError&gt; {
      todo!();
  }
}

impl TryFrom&lt;String&gt; for Imei {
  type Error = ValidateImeiError;

  fn try_from(imei: String) -&gt; Result&lt;Self, Self::Error&gt; {
    Self::validate(&amp;imei)?;
    Ok(Self(imei))
  }
}

fn register_phone(imei: Imei, label: String) {
  // We can certain `imei` is valid here
}</code></pre>
</section>
<section id="newtype-when-to-use" class="slide level2">
<h2>Newtype: When to Use?</h2>
<p>New types solve some problems:</p>
<ul>
<li>Orphan rule: no <code>impl</code>s for external <code>trait</code>s
on external types.</li>
<li>Allow for semantic typing (<code>url</code> example <a
href="#/url-example">from before</a>)</li>
<li>Enforce input validation.</li>
</ul>
</section>
<section id="the-raii-guard-pattern" class="slide level2">
<h2>2. The RAII Guard Pattern</h2>
<p>More robust resource handling.</p>
</section>
<section id="raii-guards-introduction" class="slide level2">
<h2>RAII Guards: Introduction</h2>
<ul>
<li>RAII: <strong>R</strong>esource <strong>A</strong>cquisition
<strong>I</strong>s <strong>I</strong>nitialization.</li>
<li>Link acquiring/releasing a resource to the lifetime of a
variable.</li>
<li>A constructor initializes the resource, the destructor frees
it.</li>
<li>Access resource through the guard.</li>
</ul>
<p><em>Do you know of an example?</em></p>
</section>
<section id="raii-guards-example" class="slide level2">
<h2>RAII Guards: Example</h2>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" style="font-size:14pt;"><code>pub struct Transaction&lt;&#39;c&gt; {
  connection: &amp;&#39;c mut Connection,
  did_commit: bool,
  id: usize,
}

impl&lt;&#39;c&gt; Transaction&lt;&#39;c&gt; {
  pub fn begin(connection: &amp;&#39;c mut Connection)
    -&gt; Self {
    let id = connection.start_transaction();
    Self { did_commit: false, id, connection }
  }

  pub fn query(&amp;self sql: &amp;str) {
    /* - snip - */
  }

  pub fn commit(self) {
      self.did_commit = true;
  }
}</code></pre>
</div><div class="column fragment" style="width:50%;">
<pre class="rust" style="font-size:14pt;"><code>impl Drop for Transaction&lt;&#39;_&gt; {
  fn drop(&amp;mut self) {
    if self.did_commit {
      self
        .connection
        .commit_transaction(self.id);

    } else {
      self
        .connection
        .rollback_transaction(self.id);
    }
  }
}</code></pre>
</div>
</div>
</section>
<section id="raii-guards-when-to-use" class="slide level2">
<h2>RAII Guards: When to Use?</h2>
<ul>
<li>Ensure a resource is freed at some point.</li>
<li>Ensure <strong>invariants</strong> hold while guard lives.</li>
</ul>
</section>
<section id="the-typestate-pattern" class="slide level2">
<h2>3. The Typestate Pattern</h2>
<p>Encode state in the type.</p>
</section>
<section id="typestate-introduction" class="slide level2">
<h2>Typestate: Introduction</h2>
<ul>
<li>Define <strong>uninitializable types</strong> for each state of your
object <code>O</code>.</li>
</ul>
<pre class="rust"><code>pub enum Ready {} // No variants, cannot be initialized</code></pre>
<div>
<ul>
<li class="fragment"><p>Implement methods on <code>O</code> <strong>only
for relevant</strong> states.</p></li>
<li class="fragment"><p>Methods on <code>O</code> that <strong>update
state</strong> take <strong>owned <code>self</code></strong> and return
instance with new state.</p></li>
<li class="fragment"><p>Make your type generic over its state using
<code>std::marker::PhantomData</code>. <em>üëª
<code>PhantomData&lt;T&gt;</code> makes types act like they own a
<code>T</code>, and takes no space</em>.</p></li>
</ul>
</div>
</section>
<section id="typestate-example" class="slide level2">
<h2>Typestate: Example</h2>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" style="font-size:14pt;"><code>pub enum Idle {} // Nothing to do.
pub enum ItemSelected {} // Item was selected.
pub enum MoneyInserted {} // Money was inserted.

pub struct CandyMachine&lt;S&gt; {
  state: PhantomData&lt;S&gt;,
}
impl&lt;S&gt; CandyMachine&lt;S&gt; {
  /// Just update the state
  fn into_state&lt;NS&gt;(self) -&gt; CandyMachine&lt;NS&gt; {
    CandyMachine { state: PhantomData, }
  }
}
impl CandyMachine&lt;Idle&gt; {
  pub fn new() -&gt; Self {
    Self { state: PhantomData }
  }
}</code></pre>
</div><div class="column" style="width:50%;">
<pre class="rust" style="font-size:14pt;"><code>impl CandyMachine&lt;Idle&gt; {
  fn select_item(self, item: usize)
    -&gt; CandyMachine&lt;ItemSelected&gt; {
    println!(&quot;Selected item {item}&quot;);
    self.into_state()
  }
}
impl CandyMachine&lt;ItemSelected&gt; {
  fn insert_money(self)
    -&gt; CandyMachine&lt;MoneyInserted&gt; {
    println!(&quot;Money inserted!&quot;);
    self.into_state()
  }
}
impl CandyMachine&lt;MoneyInserted&gt; {
  fn make_beverage(self)
    -&gt; CandyMachine&lt;Idle&gt; {
    println!(&quot;There you go!&quot;);
    self.into_state()
  }
}</code></pre>
</div>
</div>
</section>
<section id="typestate-when-to-use" class="slide level2">
<h2>Typestate: When to Use?</h2>
<ul>
<li>If your problem is like a state machine.</li>
<li>Ensure <em>at compile time</em> that no invalid operation is
done.</li>
</ul>
<div>
<p><em>References: Look at <a
href="https://docs.rs/serde/latest/serde/ser/trait.Serializer.html"
target="_blank"><code>serde::Serialize</code></a> and
<code>serialize_struct</code> which starts the typestate
pattern.</em></p>
</div>
</section>
<section id="the-strategy-pattern" class="slide level2">
<h2>4. The Strategy Pattern</h2>
<p>Select behavior dynamically.</p>
</section>
<section id="strategy-introduction" class="slide level2">
<h2>Strategy: Introduction</h2>
<ul>
<li>Turn set of behaviors into objects.</li>
<li>Make them interchangeble inside context.</li>
<li>Execute strategy depending on input.</li>
</ul>
<p><em>Trait objects work well here!</em></p>
</section>
<section id="strategy-example" class="slide level2">
<h2>Strategy: Example</h2>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust"><code>trait PaymentStrategy {
  fn pay(&amp;self);
}

struct CashPayment;
impl PaymentStrategy for CashPayment {
  fn pay(&amp;self) {
    println!(&quot;ü™ôüí∏&quot;);
  }
}

struct CardPayment;
impl PaymentStrategy for CardPayment {
  fn pay(&amp;self) {
    println!(&quot;üí≥&quot;);
  }
}</code></pre>
</div><div class="column fragment" style="width:50%;">
<pre class="rust"><code>fn main() {
  let method = todo!(&quot;Read input&quot;);

  let strategy: &amp;dyn PaymentStrategy
    = match method {
    &quot;card&quot; =&gt; &amp;CardPayment,
    &quot;cash&quot; =&gt; &amp;CashPayment,
    _ =&gt; panic!(&quot;Oh no!&quot;),
  };

  strategy.pay();
}</code></pre>
</div>
</div>
</section>
<section id="strategy-when-to-use" class="slide level2">
<h2>Strategy: When to Use?</h2>
<ul>
<li>Switch algorithms based on some <strong>run-time parameter</strong>
(input, config, ‚Ä¶).</li>
</ul>
</section>
<section id="anti-patterns" class="slide level2">
<h2>Anti-Patterns</h2>
<p>What <em>not</em> to do</p>
</section>
<section id="deref-polymorphism" class="slide level2">
<h2>Deref Polymorphism</h2>
<p>A common pitfall you‚Äôll want to avoid.</p>
</section>
<section id="deref-polymorphism-example" class="slide level2">
<h2>Deref Polymorphism: Example</h2>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust"><code>use std::ops::Deref;

struct Animal {
    name: String,
}

impl Animal {
    fn walk(&amp;self) {
        println!(&quot;Tippy tap&quot;)
    }
    fn eat(&amp;self) {
        println!(&quot;Om nom&quot;)
    }
    fn say_name(&amp;self) {
        // Animals generally can&#39;t speak
        println!(&quot;...&quot;)
    }
}</code></pre>
</div><div class="column" style="width:60%;">
<pre class="rust"><code>struct Dog {
    animal: Animal
}
impl Dog {
    fn eat(&amp;self) {
        println!(&quot;Munch munch&quot;);
    }
    fn bark(&amp;self) {
        println!(&quot;Woof woof!&quot;);
    }
}
impl Deref for Dog {
    type Target = Animal;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.animal
    }
}
fn main (){
    let dog: Dog = todo!(&quot;Instantiate Dog&quot;);
    dog.bark();
    dog.walk();
    dog.eat();
    dog.say_name();
}</code></pre>
</div>
</div>
</section>
<section id="the-output" class="slide level2">
<h2>The Output</h2>
<pre class="txt"><code>Woof woof!
Tippy tap
Munch munch
...</code></pre>
<p><em>Even overloading works!</em></p>
</section>
<section id="why-is-it-bad" class="slide level2">
<h2>Why Is It Bad?</h2>
<div>
<ul>
<li class="fragment">No <em>real</em> inheritance: <code>Dog</code> is
no subtype of <code>Animal</code>.</li>
<li class="fragment">Traits on <code>Animal</code> are not implemented
on <code>Dog</code> automatically.</li>
<li class="fragment"><code>Deref</code> and <code>DerefMut</code>
intended for ‚Äòpointer-to-<code>T</code>‚Äô to <code>T</code>
conversions.</li>
<li class="fragment">Deref coercion by <code>.</code> ‚Äòconverts‚Äô
<code>self</code> from <code>Dog</code> to <code>Animal</code></li>
<li class="fragment">Rust favours <strong>explicit conversions</strong>
for easier reasoning about code.</li>
</ul>
</div>
<div class="fragment">
<p><em>Confusion: for OOP programmers it‚Äôs incomplete, for Rust
programmers it is unidiomatic</em>.</p>
<h3 id="dont-do-oop-in-rust">‚ö†Ô∏è Don‚Äôt do OOP in Rust!</h3>
</div>
</section>
<section id="what-to-do-instead" class="slide level2">
<h2>What to Do Instead?</h2>
<ul>
<li><em>Move away from OOP constructs</em></li>
<li>Compose your <code>struct</code>s.</li>
<li>Use the <a
href="https://refactoring.guru/design-patterns/facade/rust/example"
target="_blank">facade pattern</a> and methods.</li>
<li>Use <code>AsRef</code> and <code>AsMut</code> for explicit
conversion.</li>
</ul>
<aside class="notes">
<ul>
<li>Facade pattern: Make an object which intracts with different types
to accomplish some logic. E.g. A filtering type <code>GraphFilter</code>
which provides a filtering interface which acts on a graph type
<code>Graph</code> and a filter lambda <code>FilterFunc</code>. It might
provide different methods for filtering.</li>
</ul>
</aside>
</section>
<section id="more-anti-patterns" class="slide level2">
<h2>More Anti-Patterns</h2>
<ul>
<li>Use global state: Singleton patterns and global variables.</li>
<li>Forcing dynamic dispatch in libraries.</li>
<li><code>clone()</code> <em>to satisfy the borrow checker</em>.</li>
<li><code>unwrap()</code> or <code>expect()</code> <em>to handle
conditions that are recoverable or not impossible</em></li>
</ul>
</section></section>
<section>
<section id="testing-your-crate" class="title-slide slide level1">
<h1>Testing your Crate</h1>
<aside class="notes">
<p>Next up: testing your crate. In bigger projects, automatic testing is
key if you want to keep bugs away. In this section we will discuss some
Rust functionalities that will help you test your application.</p>
</aside>
</section>
<section id="testing-methods" class="slide level2">
<h2>Testing Methods</h2>
<ul>
<li>Testing for correctness:
<ul>
<li>Unit tests</li>
<li>Integration tests</li>
</ul></li>
<li>Testing for performance:
<ul>
<li>Benchmarks</li>
</ul></li>
</ul>
<aside class="notes">
<p>Automatic testing can help you verify the correctness of your code,
as well as test performance.</p>
<ul>
<li>A common of testing correctness are by setting up unit tests, which
test a small piece of functionality, a unit.</li>
<li>If you want to test the correctness of interaction between those
units, you can set up integration test.</li>
<li>However, if you want to test performance, you can use benchmarking.
Let‚Äôs go over how Rust supports these various testing methods.</li>
</ul>
</aside>
</section>
<section id="unit-tests" class="slide level2">
<h2>Unit Tests</h2>
<ul>
<li>Tests a single function or method.</li>
<li>Live in child module.</li>
<li>Can test private code.</li>
</ul>
<p>To run:</p>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="bash" style="font-size:14pt;"><code>cargo test
...
running 2 tests
test tests::test_swap_items ... ok
test tests::test_swap_oob - should panic ... ok
test result: ok.
    2 passed; 0 failed; 0 ignored; 0 measured;
    0 filtered out;
    finished in 0.00s
[..]</code></pre>
</div><div class="column fragment" style="width:50%;">
<pre class="bash"><code>## Don&#39;t capture stdout while running tests
cargo test -- --nocapture</code></pre>
</div>
</div>
<p><em>Rust compiles your test code into binary using a <strong>test
harness</strong> that itself has a CLI</em>:</p>
<aside class="notes">
<ul>
<li>Unit tests are great for testing behavior of a single function or
method.</li>
<li>In Rust, they live in child modules, allowing them to access private
functionality</li>
<li>Once set up, a <code>cargo test</code> is sufficient to build and
run the tests</li>
</ul>
</aside>
</section>
<section class="slide level2">

<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" style="font-size:14pt;"><code>/// Swaps two values at the `first` and
/// `second` indices of the slice.
fn swap(slice: &amp;mut [u32],
        first: usize, second: usize) {
  let tmp = slice[second];
  slice[second] = slice[first];
  slice[first] = tmp;
}
</code></pre>
</div><div class="column fragment" style="width:50%;">
<pre class="rust" data-line-numbers="8-11,28|13-19|18|21-27"
style="font-size:14pt;"><code>/// This module is only compiled in `test` configuration.
##[cfg(test)]
mod tests {
  use crate::swap;

  // Mark function as test.
  #[test]
  fn test_swap() {
    let mut array = [0, 1, 2, 3, 4, 5];
    swap(&amp;mut array[..], 1, 4);
    assert_eq!(array, [0, 4, 2, 3, 1, 5]);
  }

  #[test]
  #[should_panic] // This should panic.
  fn test_swap_oob() {
    let mut array = [0, 1, 2, 3, 4, 5];
    swap(&amp;mut array[..], 1, 6);
  }
}</code></pre>
</div>
</div>
<aside class="notes">
<p>Here‚Äôs an example of a function being tested.</p>
<p>-<code>swap</code> takes a mutable slice, as well as two indices, and
swaps the items at those indices.</p>
<ul>
<li>Below, we‚Äôve defined a module called <code>tests</code>, which is
decorated with the <code>#[cfg(test)]</code> attribute. This attribute
makes sure the module is only compiled when running tests.</li>
<li>Inside the <code>tests</code> module, we‚Äôve defined two tests and
imported the <code>swap</code> function from the parent module. The
first test, <code>test_swap</code>, sets up a slice, passes it to
<code>swap</code> along with two indices.</li>
<li><code>test_swap</code> uses the <code>assert_eq!</code> macro to
compare the affected array with an expected array. This
<code>assert_eq!</code> macro panics on inequality, making the test fail
if the outcome is not as expected.</li>
<li>The second test, <code>test_swap_oob</code> is decorated with the
<code>#[should_panic]</code> macro, meaning this test should only pass
if it panics.</li>
</ul>
<p>Q: Why should <code>test_swap_oob</code> panic?</p>
</aside>
</section>
<section id="integration-tests" class="slide level2">
<h2>Integration Tests</h2>
<ul>
<li>Tests crate public API.</li>
<li>Run with <code>cargo test</code>.</li>
<li>Defined in <code>tests</code> folder.</li>
</ul>
<pre class="bash" data-line-numbers="14"><code>tree
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ examples
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my_example.rs
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ another_mod
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ mod.rs
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ bin
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my_app.rs
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ lib.rs
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.rs
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ some_mod.rs
‚îî‚îÄ‚îÄ tests
    ‚îî‚îÄ‚îÄ integration_test.rs</code></pre>
<aside class="notes">
<p>To test your application from the outside, you can set up integration
tests. These integration tests test your crates public interface and are
also executed by running <code>cargo test</code>.</p>
<ul>
<li>They are defined in a separate folder, called
<code>tests</code></li>
</ul>
</aside>
</section>
<section id="tests-in-your-documentation" class="slide level2">
<h2>Tests in Your Documentation</h2>
<p>You can even use examples in your documentation as tests</p>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" data-line-numbers="all|5-10|6"><code>/// Calculates fibonacci number n.
///
/// # Examples
/// ```
/// # use example::fib;
/// assert_eq!(fib(2), 1);
/// assert_eq!(fib(5), 5);
/// assert_eq!(fib(55), 55);
/// ```
pub fn fib(n: u64) -&gt; u64 {
    if n &lt;= 1 {
        n
    } else {
        fib(n - 1) + fib(n - 2)
    }
}</code></pre>
</div><div class="column" style="width:50%;">
<pre class="bash"><code>cargo test --doc</code></pre>
</div>
</div>
<aside class="notes">
<ul>
<li>Note that <em>doctests</em> are executed as if they are in another
crate</li>
<li>Lines with a hash (#) in front of them are not outputted in the
generated documentation</li>
<li>Don‚Äôt try and write all your tests in doc form, only use them if you
really want to provide an example</li>
</ul>
</aside>
</section>
<section id="benchmarks" class="slide level2">
<h2>Benchmarks</h2>
<ul>
<li>Test <em>performance</em> of code (vs.¬†correctness).</li>
<li>Runs a tests many times, yield average execution time.</li>
<li><strong>Before you do benchmarking do unit testing!</strong>.</li>
</ul>
<p>Good benchmarking is <strong>Hard</strong></p>
<ul>
<li>Beware of optimizations.</li>
<li>Beware of initialization overhead.</li>
<li>Be sure your benchmark is representative.</li>
</ul>
<h3 id="more-in-exercises"><em>More in Exercises</em></h3>
<aside class="notes">
<p>Lastly, we‚Äôll briefly look at benchmarks, which test code performance
instead of correctness. Basically, a test is run many, many times, and
statistics about the execution time are gathered and reported.</p>
<ul>
<li>Note that good benchmarking is hard. You have to make sure tested
parts of your code are not optimized away when they shouldn‚Äôt be. Also,
be aware of overhead. But most of all: make sure you benchmark is
representative depending on the intended use of your code.</li>
<li>We‚Äôll go a bit deeper into benchmarking in the exercises.</li>
</ul>
</aside>
</section></section>
    </div>
  </div>

  <script src="plugin/code-blocks/move-data-attributes.js"></script>
  <script src="plugin/highlight/add-keywords.js"></script>

  <script src="dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script src="plugin/math/math.js"></script>
  <script src="plugin/search/search.js"></script>
  <script src="plugin/zoom/zoom.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/menu/menu.js"></script>

  <script>
      moveDataAttributesToCodeElement()

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'fade',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1200,

        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 5.0e-2,

        // Bounds for smallest/largest possible scale to apply to content
        minScale: 0.1,

        maxScale: 2,
        mathjax3: {
          mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg-full.js',
          tex: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
          },
        },

        // Reveal Menu Plugin:
        // https://github.com/denehyg/reveal.js-menu/tree/2.1.0?tab=readme-ov-file
        menu: {
            // Specifies which side of the presentation the menu will
            // be shown. Use 'left' or 'right'.
            side: 'left',

            // Specifies the width of the menu.
            // Can be one of the following:
            // 'normal', 'wide', 'third', 'half', 'full', or
            // any valid css length value
            width: 'normal',

            // Add slide numbers to the titles in the slide list.
            // Use 'true' or format string (same as reveal.js slide numbers)
            numbers: false,

            // Specifies which slide elements will be used for generating
            // the slide titles in the menu. The default selects the first
            // heading element found in the slide, but you can specify any
            // valid css selector and the text from the first matching
            // element will be used.
            // Note: that a section data-menu-title attribute or an element
            // with a menu-title class will take precedence over this option
            titleSelector: 'h1, h2, h3, h4, h5, h6',

            // If slides do not have a matching title, attempt to use the
            // start of the text content as the title instead
            useTextContentForMissingTitles: false,

            // Hide slides from the menu that do not have a title.
            // Set to 'true' to only list slides with titles.
            hideMissingTitles: false,

            // Adds markers to the slide titles to indicate the
            // progress through the presentation. Set to 'false'
            // to hide the markers.
            markers: true,

            // Specify custom panels to be included in the menu, by
            // providing an array of objects with 'title', 'icon'
            // properties, and either a 'src' or 'content' property.
            custom: false,

            // Specifies the themes that will be available in the themes
            // menu panel. Set to 'true' to show the themes menu panel
            // with the default themes list. Alternatively, provide an
            // array to specify the themes to make available in the
            // themes menu panel, for example...
            //
            // [
            //     { name: 'Black', theme: 'dist/theme/black.css' },
            //     { name: 'White', theme: 'dist/theme/white.css' },
            //     { name: 'League', theme: 'dist/theme/league.css' },
            //     {
            //       name: 'Dark',
            //       theme: 'lib/reveal.js/dist/theme/black.css',
            //       highlightTheme: 'lib/reveal.js/plugin/highlight/monokai.css'
            //     },
            //     {
            //       name: 'Code: Zenburn',
            //       highlightTheme: 'lib/reveal.js/plugin/highlight/zenburn.css'
            //     }
            // ]
            //
            // Note: specifying highlightTheme without a theme will
            // change the code highlight theme while leaving the
            // presentation theme unchanged.
            themes: false,

            // Specifies the path to the default theme files. If your
            // presentation uses a different path to the standard reveal
            // layout then you need to provide this option, but only
            // when 'themes' is set to 'true'. If you provide your own
            // list of themes or 'themes' is set to 'false' the
            // 'themesPath' option is ignored.
            themesPath: 'dist/theme/',

            // Specifies if the transitions menu panel will be shown.
            // Set to 'true' to show the transitions menu panel with
            // the default transitions list. Alternatively, provide an
            // array to specify the transitions to make available in
            // the transitions panel, for example...
            // ['None', 'Fade', 'Slide']
            transitions: false,

            // Adds a menu button to the slides to open the menu panel.
            // Set to 'false' to hide the button.
            openButton: true,

            // If 'true' allows the slide number in the presentation to
            // open the menu panel. The reveal.js slideNumber option must
            // be displayed for this to take effect
            openSlideNumber: false,

            // If true allows the user to open and navigate the menu using
            // the keyboard. Standard keyboard interaction with reveal
            // will be disabled while the menu is open.
            keyboard: true,

            // Normally the menu will close on user actions such as
            // selecting a menu item, or clicking the presentation area.
            // If 'true', the sticky option will leave the menu open
            // until it is explicitly closed, that is, using the close
            // button or pressing the ESC or m key (when the keyboard
            // interaction option is enabled).
            sticky: false,

            // If 'true' standard menu items will be automatically opened
            // when navigating using the keyboard. Note: this only takes
            // effect when both the 'keyboard' and 'sticky' options are enabled.
            autoOpen: true,

            // If 'true' the menu will not be created until it is explicitly
            // requested by calling RevealMenu.init(). Note this will delay
            // the creation of all menu panels, including custom panels, and
            // the menu button.
            delayInit: false,

            // If 'true' the menu will be shown when the menu is initialised.
            openOnInit: false,

            // By default the menu will load it's own font-awesome library
            // icons. If your presentation needs to load a different
            // font-awesome library the 'loadIcons' option can be set to false
            // and the menu will not attempt to load the font-awesome library.
            loadIcons: true
        },

        highlight: {
          highlightOnLoad: false,
          beforeHighlight: (hljs) => {
            const keywords = new Map([
              [ "bash", [ "cargo","rustc" ] ]
            ]);
            addHighlightJSKeywords(hljs, keywords)

            // Run the plugin's highlighting code that was skipped on load
            Array.from(Reveal.getRevealElement().querySelectorAll('pre code')).forEach((block) => {
                RevealHighlight().highlightBlock(block);
            });
          }
        },

        // reveal.js plugins
        plugins: [
          RevealNotes,
          RevealSearch,
          RevealZoom,
          RevealHighlight,
          RevealMath.MathJax3,
          RevealMenu
        ]
      });
    </script>
    </body>
</html>
