<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Gabriel N√ºtzi, gabriel.nuetzi@sdsc.ethz.ch">
  <title>Rust Workshop ü¶Ä</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@5.1.0/dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@5.1.0/dist/reveal.css">
  <style>
    .reveal .sourceCode {  /* see #7635 */
      overflow: visible;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>

  <link rel="stylesheet" href="dist/theme/company.css" />
  <link rel="stylesheet" href="plugin/highlight/styles/railscasts.css" />

  <script>
      // If decktape export we need to load some other css
      // Emoji-Convertion
      if (window.location.search.match(/decktape/gi)) {
        let link = document.createElement("link")
        link.rel = "stylesheet"
        link.type = "text/css"
        link.href = "css/print/decktape.css"
        document.getElementsByTagName("head")[0].appendChild(link)
      }
    </script>

  <link rel="stylesheet" href="presentations/part-1/css/custom.css"/>
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Rust Workshop ü¶Ä</h1>
  <h3 class="subtitle">Part 1: From Python to Rust - Fundamentals</h3>
  <p class="author"><strong>Gabriel N√ºtzi</strong>, <a
href="mailto:gabriel.nuetzi@sdsc.ethz.ch">gabriel.nuetzi@sdsc.ethz.ch</a></p>
  <p class="date"><p>August 14, 2024 (updated May 23, 25), <a
href="https://sdsc-ordes.github.io/technical-presentation/gh-pages/rust-workshop/part-2"
target="_blank">Part 2</a></p></p>
</section>

<section class="slide level2">

<!-- markdownlint-disable-file MD034 MD033 MD001 MD024 MD026 -->
</section>
<section>
<section id="preface" class="title-slide slide level1">
<h1>Preface</h1>
<blockquote>
<p>The Rust programming language absolutely positively sucks <sub><a
href="https://www.reddit.com/r/rust/comments/12b7p2p/the_rust_programming_language_absolutely"
target="_blank">Reedit</a></sub></p>
</blockquote>
<div class="columns">
<div class="column" style="align-content:center">
<div>
<ul>
<li class="fragment"><p><strong>Python</strong>: Runtime Mess üêû
üí£</p></li>
<li class="fragment"><p><strong>Rust</strong>: Compile-Time Mess üîß
(deps. on your level of experience)</p></li>
</ul>
</div>
</div><div class="column" style="width:50%;">
<p class="center-content">
<img
data-src="presentations/part-1/assets/images/convert/presentations/part-1/assets/images/rust-muscle-crab.jpg"
class="border-dark" style="width:400px" />
</p>
</div>
</div>
<aside class="notes">
<p>Hello everyone, and a warm welcome to this Rust workshop! I‚Äôm
thrilled to see that Rust has sparked such interest within our team, and
that you‚Äôre eager to dive into this language. I‚Äôve designed the first
part of this presentation with a focus on the Python ecosystem, since
Python is widely used here at SDSC and is likely your go-to
language.</p>
<p>My goal is that by the end of this workshop, you‚Äôll not only have a
new perspective on Python but also develop a genuine appreciation for
Rust. I‚Äôve put together a self-contained learning course with now 200
slides and about 10 exercises for the core concepts to build a strong
foundation. While it might seem like a lot, I believe it‚Äôs important to
thoroughly understand the core concepts rather than just picking them up
on the fly, which can be more challenging‚Äîespecially if you‚Äôre primarily
experienced with Python, where many computer-science related things are
hidden under the hood.</p>
<p>We‚Äôll start with the basics and gradually move on to more advanced
topics. Where we finish will depend on your interests, and I can tell
you now, we definitely won‚Äôt wrap up in just two days!</p>
<p>A disclaimer before we start: I hope and expect that your perspective
on Python will shift towards the negative end =). There is to say that
Rust is not a silver-bullet. Its a complicated language with a steep
learning curve and also has its quirks and dark spots. We can abbreviate
Python more or less like ‚ÄúRun-Time Mess‚Äù and Rust with ‚ÄúCompile-Time
Mess‚Äù.</p>
<p>Rusts mascot by the way is called Ferris the Crab because some Rust
developers call themself Rustoceans. I let AI generate Ferris with super
powers, thats what it spit out =)</p>
<p>OK, its a bit intimidating.</p>
</aside>
</section>
<section id="how-i-learned---rsfluid" class="slide level2">
<h2>How I Learned? <span class="fragment">- <a
href="https://github.com/gabyx/rsfluid"
target="_blank">RsFluid</a></span></h2>
<div class="center-content">
<iframe width="840" height="472" src="https://www.youtube.com/embed/qZvKNIiBiw4?si=L6Hqc-9qke9qTOKX" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen>
</iframe>
</div>
<aside class="notes">
<p>I learned Rust the hard-way by just raw-dogging a ‚Äòsimple‚Äô fluid
simulation. I had experience from C++, but even with that it was not a
quite smooth learning curve as I just pumped into all sorts of concepts
which I had to read up on and was not so familiar with, such as ‚Äúhow the
heck move semantics work in Rust compared to C++‚Äù. Nowadays I feel,
especially with targeting Python, it makes more sense to learn first the
basics and concepts. And that‚Äôs what I like to target in this a
workshop.</p>
<p>Without further ado: Lets dive into the Rustocean.</p>
</aside>
</section></section>
<section id="help" class="title-slide slide level1">
<h1>Help</h1>
<p>How to use these slides:</p>
<ul>
<li><kbd>S</kbd>: See the speaker notes.</li>
<li><kbd>Esc</kbd>: See all slides and jump around.</li>
<li><kbd>Space</kbd>: Go forward.</li>
<li><kbd>Shift</kbd> + <kbd>Space</kbd>: Go backward.</li>
</ul>
</section>

<section id="acknowledgment" class="title-slide slide level1">
<h1>Acknowledgment</h1>
<p>Thanks to the following contributors who fixed typos and
mistakes:</p>
<ul>
<li><p>The ORDES Team (SDSC) and Jusong Yu (PSI), who helped me fixing
typos &amp; bugs.</p></li>
<li><p>Gerry Br√§unlich, Michael Kefeder &amp; Stefan T√ºx who allowed me
to attend the <a href="https://rustfest.ch" target="_blank">Rust
Fest</a> and pointing me to interesting teaching material.</p></li>
</ul>
<p>External:</p>
<ul>
<li><a href="https://github.com/trifectatechfoundation/teach-rs"
target="_blank">TeachRs</a>: Exercises and course material.</li>
<li><a href="https://google.github.io/comprehensive-rust"
target="_blank">Comprehensive Rust</a>: Inspiration.</li>
</ul>
<!-- markdownlint-disable-file MD034 MD033 MD001 MD024 MD026-->
</section>

<section>
<section id="links" class="title-slide slide level1">
<h1>Links</h1>

</section>
<section id="rust-workshop" class="slide level2">
<h2>Rust Workshop</h2>
<ul>
<li><p><a href="https://github.com/sdsc-ordes/rust-workshop"
target="_blank">Rust Workshop Exercises</a>: These are the exercises we
do during the workshop.</p></li>
<li><p><a
href="https://github.com/sdsc-ordes/technical-presentation/tree/gabriel.nuetzi/rust-workshop"
target="_blank">Slides Source</a>: The slides of this
presentation.</p></li>
</ul>
</section>
<section id="rust-references" class="slide level2">
<h2>Rust References</h2>
<ul>
<li><p><a href="https://www.rust-lang.org/learn"
target="_blank"><strong>Official Learning Reference</strong></a>: Entry
to all your needs.</p></li>
<li><p><a href="https://doc.rust-lang.org/std"
target="_blank"><strong>Rust Standard Library</strong></a>: The Rust
standard library to search for common functionality.</p></li>
<li><p><a href="https://doc.rust-lang.org/book"
target="_blank"><strong>Rust Book</strong></a>: The extensive Rust book
explaining topics in more (stm. too much) detail.</p></li>
<li><p><a href="https://doc.rust-lang.org/rust-by-example"
target="_blank"><strong>Rust By Example</strong></a>: A summary about
different Rust topics by small examples. This is good to get a first
grasp of it.</p></li>
<li><p><a href="https://rustlings.cool/"
target="_blank"><strong>Rustling</strong></a>: More exercises. We also
use some of these in our exercises.</p></li>
<li><p><a
href="https://blessed.rs/crates#section-common-subsection-error-handling"
target="_blank"><strong>Library Best-Practices</strong></a>: For every
use case there is a good library out there.</p></li>
<li><p><a href="https://www.youtube.com/@BedroomBuilds/videos"
target="_blank"><strong>Videos: From Python To
Rust</strong></a></p></li>
</ul>
<!-- markdownlint-disable-file MD034 MD033 MD001 MD024 MD026-->
</section></section>
<section>
<section id="why-rust" class="title-slide slide level1">
<h1>Why Rust</h1>

</section>
<section id="what-the-heck-is-rust" class="slide level2">
<h2>What the Heck is Rust ü¶Ä</h2>
<h3 id="a-multi-paradigm-language">A Multi-Paradigm Language</h3>
<ul>
<li><p>Procedural like Python, i.e.¬†<em>functions</em> Û∞äï, <em>loops</em>
Û∞ëô, ‚Ä¶</p></li>
<li><p>Functional aspects, i.e.¬†<em>iterators</em> üèÉ, <em>lambdas</em>
Û∞°± ‚Ä¶</p></li>
<li><p>Object-oriented aspects but unlike Python (Ó™ú its better ‚ù§Ô∏è)
‚Ä¶</p></li>
</ul>
</section>
<section id="what-the-heck-is-rust-1" class="slide level2">
<h2>What the Heck is Rust ü¶Ä</h2>
<h4 id="a-compiled-language-unlike-python">A <strong>Compiled</strong>
Language Unlike Python</h4>
<div>
<ul>
<li class="fragment"><p>The Rust compiler <code>rustc</code> ü¶Ä will
convert your code to machine-code ‚öôÔ∏è. <br> Python is an
interpreter.</p></li>
<li class="fragment"><p>It has a <strong>strong type system</strong> (<a
href="TODO">algebraic types</a>: sum types, product types).</p></li>
<li class="fragment"><p>It was invented in 2009 by Mozilla (Firefox) -
Rust Foundation as the driver today.</p></li>
</ul>
</div>
<p><span class="fragment">Note: 10% of Firefox is in Rust for good
reasons you will realize in the following.</span></p>
</section>
<section id="benefits-you-get-on-the-journey" class="slide level2">
<h2>Benefits You Get on the ü¶Ä Journey</h2>
<p>A few selling points for <code>python</code> programmers.</p>
<div>
<ul>
<li class="fragment"><p><a href="https://pypi.org/project/pydantic-core"
target="_blank"><code>pydantic-core</code></a> is fully rewritten in
Rust.</p></li>
<li class="fragment"><p>Modern <code>python</code> toolchains are in
Rust: (<a href="https://docs.astral.sh/uv/concepts/tools"
target="_blank"><code>uv</code></a>, <a
href="https://docs.astral.sh/ruff"
target="_blank"><code>ruff</code></a>, etc.).</p></li>
<li class="fragment"><p>Rust can powerup your python project seamlessly
with <a href="https://pyo3.rs"
target="_blank"><code>pyo3</code></a>.</p></li>
</ul>
</div>
</section>
<section id="come-on-show-me-syntax" class="slide level2">
<h2>Come on üê® show me syntax!</h2>
<p>The syntax* is similar and as easy to read as in Python</p>
<!-- prettier-ignore-start -->
<div class="columns">
<div class="column" style="width:40%;">
<pre class="python"><code>@dataclass
class Apple:
  name: str


def grow() -&gt; List[Apple]:
  apples = [Apple(&quot;a&quot;),
            Apple(&quot;b&quot;)]

  for b in apples:
    print(f&quot;Apple: {b.name}&quot;)


  return apples</code></pre>
</div><div class="column" style="width:60%;">
<pre class="rust"><code>#[derive(Debug)]
struct Apple {
  name: String
}

fn grow() -&gt; Vec&lt;Apple&gt; {
  let apples = vec![Apple{name: &quot;a&quot;.to_string()},
                    Apple{name: &quot;b&quot;.to_string()} ];

  for b in &amp;apples {
    println!(&quot;Apple: {b:?}&quot;);
  }

  apples
}</code></pre>
</div>
</div>
<p>*: 80% you will encounter is very readable (except macros etc.).</p>
<!-- prettier-ignore-end -->
</section>
<section id="but-why" class="slide level2">
<h2>But Why?</h2>
<h3>
More reasons why you should learn a <em class="emph">compiled,
statically typed</em> </span>language‚Ä¶
</h3>
</section>
<section class="slide level2">

<h3 id="what-rust-promises">What Rust Promises ü§ö</h3>
<div>
<div class="center-content">
<ol type="1">
<li class="fragment"><strong>Pedal to the Metal</strong></li>
<li class="fragment"><strong>Comes with a Warranty</strong></li>
<li class="fragment"><strong>Beautiful Code</strong></li>
<li class="fragment"><strong>Rust is Practical</strong></li>
</ol>
</div>
</div>
</section>
<section id="pedal-to-the-metal" class="slide level2">
<h2>Pedal to the Metal</h2>
<div>
<ul>
<li class="fragment"><p>Compiled language, not interpreted.</p></li>
<li class="fragment"><p>State-of-the-art machine-code generation using
LLVM.</p></li>
<li class="fragment"><p>No garbage collector (GC) getting in the way of
execution.</p>
<pre class="python" data-line-numbers=""><code>def run():
  d = { &quot;a&quot;:1, &quot;b&quot;:2 } # Memory is allocated on the heap.

run()</code></pre>
<p><strong>Question:</strong> Does the memory of <code>d</code> still
exist after <code>run()</code>?</p>
<p><span class="fragment">Ó™ú We don‚Äôt know ü§∑</span></p></li>
<li class="fragment"><p>Usable in embedded devices, operating systems
and demanding websites.</p></li>
</ul>
</div>
<aside class="notes">
<p>Explain what a garbage collector does explain what the heap/stack are
later.</p>
</aside>
</section>
<section id="rust-comes-with-a-warranty" class="slide level2">
<h2>Rust Comes with a Warranty</h2>
<div>
<ul>
<li class="fragment"><p>Strong type system helps prevent silly bugs
üêû:</p>
<pre class="python"><code>def concat(numbers: List[str]) -&gt; str:
  return &quot;-&quot;.join(numbers)

concat([&quot;1&quot;, &quot;2&quot;, &quot;30&quot;, 4, &quot;5&quot;, &quot;7&quot;, &quot;10&quot;])</code></pre></li>
<li class="fragment"><p>Explicit errors instead of exceptions ‚ùó(<a
href="TODO">later</a>):</p>
<pre class="python"><code>def main():
  file_count = get_number_of_files()
  if file_count is None:
    print(&quot;Could not determine file count.&quot;)</code></pre>
<p><span class="fragment"><strong>Question:</strong> Is this error
handling correct if: <br> <code
class="python">get_number_of_files = lambda: int(sys.argv[0])</code></span></p></li>
</ul>
</div>
<aside class="notes">
<ul>
<li>You are reading <code>argv[0]</code> which is a string, namely the
path of your script/program.</li>
</ul>
</aside>
</section>
<section id="rust-comes-with-a-warranty-1" class="slide level2">
<h2>Rust Comes with a Warranty</h2>
<div>
<ul>
<li class="fragment"><p><strong>Ownership Model</strong>: Type system
tracks lifetime of objects.</p>
<ul>
<li class="fragment">No more exceptions about accessing
<code>None</code>.</li>
<li class="fragment">You know who owns an objects
(variable/memory).</li>
</ul></li>
<li class="fragment"><p>Programs don‚Äôt trash your system
accidentally</p>
<ul>
<li class="fragment">Warranty <em>can</em> be voided
(<code>unsafe</code>).</li>
</ul></li>
</ul>
</div>
<aside class="notes">
<p>Throws two exceptions: <code>ValueError</code> and
<code>TypeError</code>. <strong>Ownership Model</strong>: Strict rules
on how memory is managed and shared Ó™ú Safe Code ü¶∫. (<small>Note:
variables bind to memory</small>)</p>
</aside>
</section>
<section id="rust-comes-with-a-warranty-2" class="slide level2">
<h2>Rust Comes with a Warranty</h2>
<p><strong>Experience: <span class="emph"><em>‚Äú‚ô•Ô∏è If it compiles, it is
more often correct. ‚ô•Ô∏è‚Äù</em></span></strong></p>
<div>
<ul>
<li class="fragment"><p>Enables <a
href="https://www.youtube.com/watch?v=Kdpfhj3VM04"
target="_blank">compiler driven development</a>.</p></li>
<li class="fragment"><p>100% code coverage:</p>
<div class="columns">
<div class="column fragment" style="width:50%;">
<pre class="python smaller-code"><code>def get_float(num: str | float) -&gt; float:
  match (num):
      case str(num):
          return float(num)</code></pre>
<p><em>You trust <code>mypy</code> which is not enforced at
runtime.</em></p>
</div><div class="column fragment" style="width:50%;">
<pre class="rust smaller-code"><code>enum StrOrFloat {
  MyStr(String),
  MyFloat(f64),
}

fn get_float(n: StrOrFloat) -&gt; f64 {
    match n {
        StrOrFloat::MyFloat(x) =&gt; x,
    }
}</code></pre>
</div>
</div></li>
</ul>
</div>
<aside class="notes">
<p>Rust allows quite a different programming experience. It‚Äôs called
<strong>compiler driven development</strong> (e.g.¬†guard your business
logic with the type-system at your hand, e.g.¬†type-state pattern. I
explain threads later. Certain statements allow <code>rustc</code> to
check that you covered all cases. Python: With power comes
responsibility. Python is very dynamic, but this duck-typing and
non-strictness results often in a mess.</p>
</aside>
</section>
<section id="rust-comes-with-a-warranty-3" class="slide level2">
<h2>Rust Comes with a Warranty</h2>
<p><strong>Experience: <span class="emph"><em>‚Äú‚ô•Ô∏è If it compiles, it is
more often correct. ‚ô•Ô∏è‚Äù</em></span></strong></p>
<ul>
<li>No invalid syntax.</li>
<li>Guaranteed thread safety.</li>
<li>Model your business logic with <code>struct</code> and
<code>enums</code>.</li>
</ul>
<aside class="notes">
<p>My experience with python and rust is it is depend on the developer
to write/organize good or bad code, but it is easier (or lean to) write
bad code in python, but it is hard to write bad rust code. The compiler
is like a good teacher who hold your hands and help you writing
performance and maintainable code. When it compiled it works.</p>
</aside>
</section>
<section id="performance" class="slide level2">
<h2>Performance</h2>
<div>
<ul>
<li class="fragment"><p>Rust is <strong>fast</strong> üöÄ. Comparable to
C++/C, faster than <code>go</code>.</p>
<ul>
<li class="fragment"><em>Python is slow, that‚Äôs why most libraries
outsource to C or <a href="https://github.com/PyO3/pyo3"
target="_blank"><code>Rust</code></a>.</em></li>
</ul></li>
<li class="fragment"><p>Rust is <strong>concurrent</strong> ‚áâ by design
<em>(safe-guarded by the ownership model)</em>.</p>
<ul>
<li class="fragment">Python has an <a
href="https://realpython.com/python-gil/" target="_blank">interpreter
lock (GIL)</a> which prohibits proper threading (<a
href="https://www.lesinskis.com/python-GIL-removal.html"
target="_blank">it gets removed</a>).</li>
</ul></li>
</ul>
</div>
</section>
<section id="why-should-learn-rust" class="slide level2">
<h2>Why Should ü´µ Learn Rust?</h2>
<div>
<ul>
<li class="fragment"><p>Learning a new language teaches you new
tricks:</p>
<ul>
<li class="fragment">You will also write better code (also in
Python)!</li>
</ul></li>
<li class="fragment"><p>Rust is a young, but a quickly growing
platform:</p>
<ul>
<li class="fragment">You can help shape its future.</li>
<li class="fragment">Demand for Rust programmers will increase!</li>
</ul></li>
<li class="fragment"><p>It‚Äôs not easy ‚Äî but it‚Äôs worth it:</p>
<ul>
<li class="fragment">Exercise is tough, but it makes you stronger.</li>
<li class="fragment">Junk food is easy, but it slows you down.</li>
<li class="fragment">Learning Rust is a challenge ‚Äî but soon, you‚Äôll
feel like you‚Äôre bending the Matrix.</li>
</ul></li>
</ul>
</div>
<!-- markdownlint-disable-file MD034 MD033 MD001 MD024 MD026-->
</section></section>
<section>
<section id="your-first-project" class="title-slide slide level1">
<h1>Your First Project</h1>

</section>
<section id="create-a-project" class="slide level2">
<h2>Create a Project</h2>
<pre class="bash"><code>cargo new hello-world</code></pre>
<p>Cargo is the Rust package manager. Cargo downloads your Rust
package‚Äôs dependencies, compiles your packages, makes distributable
packages, and uploads them to <a href="https://crates.io"
target="_blank">crates.io</a>, the Rust community‚Äôs package
registry.</p>
<pre class="bash"><code>cd hello-world
cargo run</code></pre>
<pre class="text"><code>Compiling hello-world v0.1.0
Finished dev [unoptimized + debuginfo] target(s) in 0.74s
Running `target/debug/hello-world`
Hello, world!</code></pre>
</section>
<section id="computing-a-simple-sum" class="slide level2">
<h2>Computing a Simple Sum</h2>
<pre class="rust" data-line-numbers="all|1-3|2|5-11|6-10|7,9|all"><code>fn main() {
    println!(&quot;sum(4) = 4 + 3 + 2 + 1 = {}&quot;, sum(4));
}

fn sum(n: u64) -&gt; u64 {
    if n != 0 {
        n + sum(n-1)
    } else {
        n
    }
}
// Note: avoid recursion as you always can :)</code></pre>
<p><strong>Output</strong>:</p>
<pre class="text"><code>sum(4) = 4 + 3 + 2 + 1 = 10</code></pre>
<aside class="notes">
<ul>
<li><code>fn main()</code> is the entrypoint of your program</li>
<li><code>println!</code> (output something to <code>stdout</code>)</li>
<li>Exclamation mark is a macro (we‚Äôll see later)</li>
<li><code>fn</code> short for function, declare a function</li>
<li><code>u64</code> unsigned integer types, all integers have an
explicit size, 64 bits in this case</li>
<li><code>if-else</code> is without parenthesis for the expression, but
with required braces for the blocks</li>
<li>no explicit return keyword (will get back to that)</li>
</ul>
</aside>
<!-- markdownlint-disable-file MD034 MD033 MD001 MD024 MD026-->
</section></section>
<section>
<section id="basic-syntax" class="title-slide slide level1">
<h1>Basic Syntax</h1>

</section>
<section id="variables-1" class="slide level2">
<h2>Variables (1)</h2>
<pre class="rust"><code>fn main() {
    let some_x = 5;
    println!(&quot;some_x = {}&quot;, some_x);
    some_x = 6;
    println!(&quot;some_x = {some_x}&quot;);
}</code></pre>
<pre class="text fragment" style="font-size:12pt;"><code>Compiling hello-world v0.1.0
error[E0384]: cannot assign twice to immutable variable `some_x`
--&gt; src/main.rs:4:5
2 |     let some_x = 5;
  |         ------
  |         |
  |         first assignment to `some_x`
  |         help: consider making this binding mutable: `mut some_x`
3 |     println!(&quot;some_x = {}&quot;, some_x);
4 |     some_x = 6;
  |     ^^^^^^^^^^ cannot assign twice to immutable variable</code></pre>
<ul>
<li>Rust uses snake case (e.g.¬†<code>some_x</code>) for variable
names.</li>
<li>The <strong>immutable</strong> (<em>read-only</em>) variable cannot
be mutated in any way.</li>
</ul>
</section>
<section id="variables-2" class="slide level2">
<h2>Variables (2)</h2>
<pre class="rust" data-line-numbers="2,4"><code>fn main() {
    let mut some_x = 5;
    println!(&quot;some_x = {}&quot;, some_x);
    some_x = 6;
    println!(&quot;some_x = {}&quot;, some_x);
}</code></pre>
<pre class="text"><code>Compiling hello-world v0.1.0 (/home/teach-rs/Projects/hello-world)
Finished dev [unoptimized + debuginfo] target(s) in 0.26s
Running `target/debug/hello-world`
some_x = 5
some_x = 6</code></pre>
<ul>
<li>Declare a <strong>mutable</strong> variable with <code>mut</code> to
update</li>
</ul>
</section>
<section id="declaring-a-type-of-variable" class="slide level2">
<h2>Declaring a Type of Variable</h2>
<pre class="rust"><code>fn main() {
    let x: i32 = 20;
    //   ^^^^^---------- Type annotation. (as in python)
}</code></pre>
<ul>
<li>Rust is strongly and strictly typed.</li>
<li>Variables use <em>type inference</em>, so no need to specify a type
(<a
href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system"
target="_blank">Henly-Millner Type System</a>), (<a
href="https://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/"
target="_blank">Understanding It</a>).</li>
<li>We can be explicit in our types (and sometimes have to be).</li>
</ul>
</section>
<section id="primitives-integers" class="slide level2">
<h2>Primitives: Integers</h2>
<!-- prettier-ignore-start -->
<div class="columns">
<div class="column" style="width:50%;">
<table>
<thead>
<tr class="header">
<th>Length</th>
<th>Signed</th>
<th>Unsigned</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>8 bits</td>
<td><code>i8</code></td>
<td><code>u8</code></td>
</tr>
<tr class="even">
<td>16 bits</td>
<td><code>i16</code></td>
<td><code>u16</code></td>
</tr>
<tr class="odd">
<td>32 bits</td>
<td><code>i32</code></td>
<td><code>u32</code></td>
</tr>
<tr class="even">
<td>64 bits</td>
<td><code>i64</code></td>
<td><code>u64</code></td>
</tr>
<tr class="odd">
<td>128 bits</td>
<td><code>i128</code></td>
<td><code>u128</code></td>
</tr>
<tr class="even">
<td>pointer-sized</td>
<td><code>isize</code></td>
<td><code>usize</code></td>
</tr>
</tbody>
</table>
<p><br></p>
</div><div class="column" style="width:50%;">
<p><strong>Literals</strong></p>
<pre class="rust"><code>let x = 42;
let y = 42u64; // decimal as u64
let z = 42_000; // underscore separator

let u = 0xff; // hexadecimal
let v = 0o77; // octal
let q = b&#39;A&#39;; // byte syntax (is u8)
let w = 0b0100_1101; // binary</code></pre>
</div>
</div>
<!-- prettier-ignore-end -->
<ul>
<li>Rust prefers explicit integer sizes.</li>
<li>Use <code>isize</code> and <code>usize</code> sparingly.</li>
</ul>
<aside class="notes">
<p>Use <code>isize</code> and <code>usize</code> mostly when working
with indexing or other things that need to have a specific size for your
platform.</p>
</aside>
</section>
<section id="primitives-floating-points-numbers" class="slide level2">
<h2>Primitives: Floating Points Numbers</h2>
<pre class="rust"><code>fn main() {
    let x = 2.0;    // f64
    let y = 1.0f32; // f32
}</code></pre>
<ul>
<li><code>f32</code>: single precision (32-bit) floating point
number.</li>
<li><code>f64</code>: double precision (64-bit) floating point
number.</li>
<li><code>f128</code>: 128-bit floating point number.</li>
</ul>
<aside class="notes">
<ul>
<li>Rust uses f64 by default</li>
<li>Similar to integers you can append the type of float to indicate a
specific literal type</li>
</ul>
</aside>
</section>
<section id="numerical-operations" class="slide level2">
<h2>Numerical Operations</h2>
<pre class="rust"><code>fn main() {
    let sum = 5 + 10;
    let difference = 10 - 3;
    let mult = 2 * 8;
    let div = 2.4 / 3.5;
    let int_div = 10 / 3; // 3
    let remainder = 20 % 3;
}</code></pre>
<div>
<ul>
<li class="fragment"><p>Overflow/underflow checking in
<strong>debug</strong>:</p>
<pre class="rust"><code>let a: u8 = 0b1111_1111;
println!(&quot;{}&quot;, a + 10); // compiler error:
               ^^^^^^ attempt to compute `u8::MAX + 10_u8`,
                      which would overflow</code></pre></li>
<li class="fragment"><p>In <strong>release builds</strong> these
expressions are wrapping, for efficiency.</p></li>
</ul>
</div>
</section>
<section id="numerical-operations-1" class="slide level2">
<h2>Numerical Operations</h2>
<ul>
<li>You cannot mix and match types, i.e.:</li>
</ul>
<pre class="rust"><code>fn main() {
    let invalid_div = 2.4 / 5;          // Error!
    let invalid_add = 20u32 + 40u64;    // Error!
}</code></pre>
<ul>
<li>Rust has your typical operations, just as with other
<code>python</code> languages.</li>
</ul>
</section>
<section id="primitives-booleans-and-operations" class="slide level2">
<h2>Primitives: Booleans and Operations</h2>
<pre class="rust"><code>fn main() {
    let yes: bool = true;
    let no: bool = false;
    let not = !no;
    let and = yes &amp;&amp; no;
    let or = yes || no;
    let xor = yes ^ no;
}</code></pre>
</section>
<section id="comparison-operators" class="slide level2">
<h2>Comparison Operators</h2>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust"><code>fn main() {
    let x = 10;
    let y = 20;
    x &lt; y;  // true
    x &gt; y;  // false
    x &lt;= y; // true
    x &gt;= y; // false
    x == y; // false
    x != y; // true
}</code></pre>
</div><div class="column" style="width:50%;">
<pre class="rust"><code>fn main() {
    3.0 &lt; 20;      // invalid
    30u64 &gt; 20i32; // invalid
}</code></pre>
</div>
</div>
<div>
<ul>
<li class="fragment"><strong>Boolean operators short-circuit</strong>:
i.e.¬†if in <code>a &amp;&amp; b</code>, <code>a</code> is already false,
then the code for <code>b</code> is not executed.</li>
</ul>
</div>
<aside class="notes">
<p>As with numerical operators, you cannot compare different integer and
float types with each other</p>
</aside>
</section>
<section id="primitives-characters" class="slide level2">
<h2>Primitives: Characters</h2>
<pre class="rust"><code>fn main() {
    let c: char = &#39;z&#39;; // Note: the single-quotes &#39;&#39;.
    let z = &#39;‚Ñ§&#39;;
    let heart_eyed_cat = &#39;üòª&#39;;
}</code></pre>
<ul>
<li>A <code>char</code> is a 32-bit <strong>unicode scalar
value</strong> (like in python).
<!-- - Very much unlike `C/C++` but like `python` where `char` is 8 bits. --></li>
</ul>
<aside class="notes">
<ul>
<li>The final scalar type is the character, but it isn‚Äôt often
seen.</li>
<li>Note that it is not the same as u8 (a byte) in Rust, and cannot be
used interchangeably.</li>
<li>We‚Äôll see later that strings do not use chars, but are encoded as
UTF-8 instead.</li>
</ul>
</aside>
</section>
<section id="strings" class="slide level2">
<h2>Strings</h2>
<pre class="rust"><code>    let s1 = String::from(&quot;Hello, üåç!&quot;);
    //       ^^^^^^ Owned, heap-allocated string</code></pre>
<div>
<ul>
<li class="fragment">Rust <code>String</code>s are UTF-8-encoded.
<!-- - Unlike C/C++: _Not null-terminated_ --></li>
<li class="fragment">Cannot be indexed like Python
<code>str</code>.</li>
<li class="fragment"><code>String</code> is heap-allocated.</li>
<li class="fragment">Actually many types of strings in Rust
<ul>
<li class="fragment"><code>CString</code></li>
<li class="fragment"><code>PathBuf</code></li>
<li class="fragment"><code>OsString</code></li>
<li class="fragment">‚Ä¶</li>
</ul></li>
</ul>
</div>
<aside class="notes">
<ul>
<li>Rusts strings are complicated, because all strings are
complicated.</li>
<li>Rusts strings are UTF-8 encoded sequences.</li>
<li>Literal strings are static by default and live for the whole life
time of the program, called string <em>slices</em>, being pointers to
their start, accompanied with the length</li>
</ul>
</aside>
</section>
<section id="primitives-tuples" class="slide level2">
<h2>Primitives: Tuples</h2>
<!-- prettier-ignore-start -->
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust fragment" style="font-size:15pt;"><code>fn main() {
  let tup: (i32, f32, char) = (1, 2.0, &#39;a&#39;);
}</code></pre>
<div>
<ul>
<li class="fragment">Group multiple values into a single compound
type.</li>
<li class="fragment">Fixed size.</li>
<li class="fragment">Different <strong>types</strong> per element.</li>
</ul>
</div>
</div><div class="column" style="width:50%;">
<pre class="rust fragment"><code>fn main() {
  let tup = (1, 2.0, &#39;Z&#39;);
  let (a, b, c) = tup;
  println!(&quot;({}, {}, {})&quot;, a, b, c);

  let another_tuple = (true, 42);
  println!(&quot;{}&quot;, another_tuple.1);
}</code></pre>
<div>
<ul>
<li class="fragment">Tuples can be <strong>destructured</strong> to get
to their individual values</li>
<li class="fragment">Access an element with <code>.</code> followed by a
zero based index.</li>
</ul>
</div>
</div>
</div>
<!-- prettier-ignore-end -->
<aside class="notes">
<ul>
<li>Note how the tuple type and the tuple value are constructed
similarly, but the type contains individual element types.</li>
<li>We will see more powerful variants of this destructuring later.</li>
<li>Note that after destructuring the original value is no longer
accessible.</li>
</ul>
</aside>
</section>
<section id="primitives-arrays" class="slide level2">
<h2>Primitives: Arrays</h2>
<pre class="rust"><code>fn main() {
    let arr: [i32; 3] = [1, 2, 3];
    println!(&quot;{}&quot;, arr[0]);

    let [a, b, c] = arr;
    println!(&quot;[{}, {}, {}]&quot;, a, b, c);
}</code></pre>
<div>
<ul>
<li class="fragment">A collection of multiple values, but <strong>same
type</strong>.</li>
<li class="fragment">Always <strong>fixed length</strong> at compile
time (similar to tuples).</li>
<li class="fragment">Use <code>[i]</code> to access an individual
<code>i</code>-th value.</li>
<li class="fragment">Destructuring as with tuples.</li>
<li class="fragment">Rust always checks array bounds when accessing a
value in an array.</li>
<li class="fragment"><strong>This is not Pythons <code>list</code>
type!</strong> (<code>Vec</code> later).</li>
</ul>
</div>
<aside class="notes">
<ul>
<li>Create an array by writing a comma-separated list of values inside
brackets</li>
<li>Note unlike <code>python</code> it must always have a length defined
at compile time and cannot be constructed dynamically</li>
<li>You can also construct an array using [value; repetitions] instead
of having to write out each value if you have a repeating value.</li>
<li>For the type declaration the element type and count are separated by
a semicolon and written between brackets</li>
</ul>
</aside>
</section>
<section id="control-flow" class="slide level2">
<h2>Control Flow</h2>
<!-- prettier-ignore-start -->
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" data-line-numbers="|3-10|4-9|8|13-16|18-20|"
style="font-size:14pt;"><code>fn main() {
    let mut x = 0;
    loop {
        if x &lt; 5 {
            println!(&quot;x: {}&quot;, x);
            x += 1;
        } else {
            break;
        }
    }

    let mut y = 5;
    while y &gt; 0 {
        y -= 1;
        println!(&quot;y: {}&quot;, y);
    }

    for i in [1, 2, 3, 4, 5] {
        println!(&quot;i: {}&quot;, i);
    }
}</code></pre>
</div><div class="column" style="width:50%;">
<ul>
<li><p>A loop or if condition must always evaluate to a boolean type, so
no <code>if 1</code>.</p></li>
<li><p>Use <code>break</code> to break out of a loop, also works with
<code>for</code> and <code>while</code>, <code>continue</code> to skip
to the next iteration.</p></li>
</ul>
</div>
</div>
<!-- prettier-ignore-end -->
</section>
<section id="functions" class="slide level2">
<h2>Functions</h2>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust"><code>fn add(a: i32, b: i32) -&gt; i32 {
    a + b // or: `return a+b;`
}

fn returns_nothing() -&gt; () {
    println!(&quot;Nothing to report&quot;);
}

fn also_returns_nothing() {
    println!(&quot;Nothing to report&quot;);
}</code></pre>
</div><div class="column" style="width:50%;">
<div>
<ul>
<li class="fragment">The function signature must be annotated with
types.</li>
<li class="fragment">Type inference may be used in function body.</li>
<li class="fragment">A function that returns nothing has the return type
<strong><em>unit</em> <code>()</code></strong></li>
<li class="fragment">Either return an expression on the <strong>last
line</strong> with <strong>no semicolon</strong> (or write
<code>return expr;</code>).</li>
</ul>
</div>
</div>
</div>
<aside class="notes">
<ul>
<li>Rust always uses snake case for variables and functions.</li>
<li>We must annotate each function parameter with a type, using a
colon.</li>
<li>We must annotate the function return type using an arrow
(<code>-&gt;</code>) followed by the return type.</li>
<li>Unit may be omitted, note the syntax looks like an empty tuple: a
tuple with no value members has no instances, just as with unit.</li>
<li>In Rust you must always specify your type signatures for function
boundaries.</li>
</ul>
</aside>
</section>
<section id="statements" class="slide level2">
<h2>Statements</h2>
<ul>
<li><a
href="https://doc.rust-lang.org/reference/statements-and-expressions.html"
target="_blank"><strong>Statements</strong></a> are instructions that
perform some action and <strong>do not return a value</strong>.</li>
<li>A definition of any kind (function definition etc.)</li>
<li>The <code>let var = expr;</code> statement.</li>
<li>Almost everything else is an <strong>expression</strong>.</li>
</ul>
<p><br></p>
<h3 id="examples">Examples</h3>
<!-- prettier-ignore-start -->
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust"><code>fn my_fun() {
    println!(&quot;{}&quot;, 5);
}</code></pre>
<pre class="rust"><code>let x = 10;</code></pre>
</div><div class="column" style="width:50%;">
<pre class="rust"><code>return 42;</code></pre>
<pre class="rust fragment"><code>let x = (let y = 10); // invalid</code></pre>
</div>
</div>
<!-- prettier-ignore-end -->
<aside class="notes">
<ul>
<li>Note how <code>let</code> within a <code>let</code> is not allowed
because of <code>let</code> being a statement, thus you may not declare
multiple variables at the same time with the same value</li>
<li><code>let</code> is a statement because ownership makes multiple
assignments behave differently than many would expect, it is almost
never what you want in Rust</li>
<li>It also makes sense if you think of all other declarations also
being statements</li>
</ul>
</aside>
</section>
<section id="expressions" class="slide level2">
<h2>Expressions</h2>
<div>
<ul>
<li class="fragment"><a
href="https://doc.rust-lang.org/reference/statements-and-expressions.html"
target="_blank"><strong>Expressions</strong></a> evaluate to a
<strong>resulting value</strong>.</li>
<li class="fragment">Expressions make up most of the Rust code you
write.</li>
<li class="fragment">Includes all control flow such as <code>if</code>
and <code>loop</code>.</li>
<li class="fragment">Includes scoping braces (<code>{</code> and
<code>}</code>).</li>
<li class="fragment">Semicolon (<code>;</code>) turns expression into
statement.</li>
</ul>
</div>
<pre class="rust" data-line-numbers="all|2-5"
data-fragment-index="0"><code>fn main() {
    let y = {
        let x = 3;
        x + 1
    };
    println!(&quot;{}&quot;, y); // 4
}</code></pre>
</section>
<section id="scope" class="slide level2">
<h2>Scope</h2>
<ul>
<li>We just mentioned the scope braces (<code>{</code> and
<code>}</code>).</li>
<li>Variable scopes are actually <strong>very important</strong> for how
Rust works.</li>
</ul>
<pre class="rust"><code>fn main() {
    println!(&quot;Hello, {}&quot;, name);  // invalid: name is not yet defined

    {
        let name = &quot;world&quot;;  // from this point name is in scope
        println!(&quot;Hello, {}&quot;, name);
    } // name goes out of scope

    println!(&quot;Hello, {}&quot;, name);  // invalid: name is no more defined
}</code></pre>
</section>
<section id="expressions---control-flow" class="slide level2">
<h2>Expressions - Control Flow</h2>
<ul>
<li><p><strong>Remember</strong>: A block/function can end with an
expression, but it needs to have the correct type</p></li>
<li><p>Control flow expressions as a statement do not <br> need to end
with a semicolon if they return <em>unit</em>
(<code>()</code>).</p></li>
</ul>
<pre class="rust" data-fragment-index="all|3-8|10-15"
style="font-size:14pt;"><code>fn main() {
    let y = 11;
    // if as an expression
    let x = if y &lt; 10 {
        42    // missing ;
    } else {
        24    // missing ;
    };

    // if (control-flow expr.) as a statement
    if x == 42 {
        println!(&quot;Foo&quot;);
    } else {
        println!(&quot;Bar&quot;);
    } // no ; necessary
}</code></pre>
</section>
<section id="expression---control-flow" class="slide level2">
<h2>Expression - Control Flow</h2>
<h3 id="quiz-does-this-compile">Quiz: Does this compile?</h3>
<!-- prettier-ignore-start -->
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" data-line-numbers=""><code>fn main() {
    if 2 &lt; 10 {
        42
    } else {
        24
    }
}</code></pre>
</div><div class="column" style="width:50%;">
<div class="fragment">
<pre class="rust" data-line-numbers="6"><code>fn main() {
    if 2 &lt; 10 {
        42
    } else {
        24
    };
}</code></pre>
<p><strong>Answer:</strong> <span class="red"><strong>No</strong></span>
- It needs a <code>;</code> on line 6 because the <code>if</code>
expression returns a value which must be turned into statement with
<code>};</code></p>
</div>
</div>
</div>
<!-- prettier-ignore-end -->
<aside class="notes">
<p>Fix the thing on the last line. Not by adding ; to 42, 24.</p>
</aside>
</section>
<section id="expression---control-flow-1" class="slide level2">
<h2>Expression - Control Flow</h2>
<h3 id="quiz-does-this-compile-1">Quiz: Does this compile?</h3>
<pre class="rust" data-line-numbers=""><code>fn main() {
    let a = if if 1 != 2 { 3 } else { 4 } == 4 {
        2
    } else {
        1
    };

    println!(&quot;{}&quot;, a)
}</code></pre>
<div class="fragment">
<p><strong>Answer:</strong> <span
class="green"><strong>Yes</strong></span> - <code>a == 1</code>.</p>
</div>
</section>
<section id="scope-more" class="slide level2">
<h2>Scope (more)</h2>
<p>When a scope ends, all variables for that scope become ‚Äúextinct‚Äù
(deallocated/removed from the stack).</p>
<!-- prettier-ignore-start -->
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" data-line-numbers="1|2|4|5|6|7|9"><code>fn main() { // nothing in scope here
  let i = 10; // i is now in scope

  if i &gt; 5 {
      let j = 20; // j is now in scope
      println!(&quot;i = {}, j = {}&quot;, i, j);
  } // j is no longer in scope

  println!(&quot;i = {}&quot;, i);
} // i is no longer in scope</code></pre>
</div><div class="column fragment" style="width:50%;">
<pre class="python" data-line-numbers=""><code>def main():
  i = 10;

  if i &gt; 5:
      j = 20
      print(f&quot;i = {j}, j = {i}&quot;)


  print(i, j) # üí©: j is STILL in scope</code></pre>
</div>
</div>
<!-- prettier-ignore-end -->
<p><strong>Note</strong>: This is very <strong>different</strong> from
<code>python</code>.</p>
</section>
<section id="printing-formatting-values" class="slide level2">
<h2>Printing &amp; Formatting Values</h2>
<p>With the <a href="https://doc.rust-lang.org/std/fmt/index.html"
target="_blank"><code>format!</code> or <code>println!</code> macros</a>
(later) you can format or print variables to <code>stdout</code> of your
application:</p>
<pre class="rust"><code>fn main() {
  let x = 130;
  let y = 50;

  println!(&quot;{} + {}&quot;, x, y);
  println!(&quot;{x} + {y}&quot;);

  let s: String = format!(&quot;{x:04} + {0:&gt;10}&quot;, y);
  println!(&quot;{s}&quot;)
}</code></pre>
<p><strong>Output:</strong></p>
<pre><code>130 + 50
130 + 50
0130 +         50</code></pre>
</section>
<section id="exercise-time-1" class="slide level2">
<h2>Exercise Time (1)</h2>
<p>Approx. Time: 20-45 min.</p>
<p>Do the following exercises:</p>
<ul>
<li><code>basic-syntax</code>: all, 09 (optional: macros, <a
href="https://doc.rust-lang.org/book/ch19-06-macros.html"
target="_blank">read here</a>)</li>
</ul>
<p><strong>Build/Run/Test:</strong></p>
<pre class="bash"><code>just build &lt;exercise&gt; --bin 01
just run &lt;exercise&gt; --bin 01
just test &lt;exercise&gt; --bin 01
just watch [build|run|test|watch] &lt;exercise&gt; --bin 01</code></pre>
</section>
<section id="did-you-fight-the-compiler" class="slide level2">
<h2>Did You Fight The Compiler?</h2>
<div class="columns">
<div class="column" style="width:50%;">
<div class="center-content">
<iframe width="315" height="560" src="https://www.youtube.com/embed/vavfBAasaHk?start=27&amp;autoplay=1&amp;mute=1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>
</iframe>
</div>
</div><div class="column fragment" style="align-content:center;">
<p>You will get better at this! ü¶Ä But it needs practice!</p>
</div>
</div>
<aside class="notes">
<p>Its vital for your benefit of this workshop and to follow up on the
more elaborate topics in the next sessions, its important to really do
the exercises. We already do the minimal amount of them.</p>
</aside>
<!-- markdownlint-disable-file MD034 MD033 MD001 MD024 MD026-->
</section></section>
<section>
<section id="move-semantics" class="title-slide slide level1">
<h1>Move Semantics</h1>

</section>
<section id="memory" class="slide level2">
<h2>Memory</h2>
<ul>
<li>A computer program consists of a set of instructions.</li>
<li>Those instructions manipulate some memory.</li>
<li>How does a program know what memory can be used?</li>
</ul>
<aside class="notes">
<ul>
<li>A program is not just the code that is running, it is also the
current state of that program (the memory).</li>
<li>But central here is the question: when does a program know when it
can use a specific part of that memory, when is it available?</li>
</ul>
</aside>
</section>
<section id="program-execution" class="slide level2">
<h2>Program Execution</h2>
<!-- prettier-ignore-start -->
<div class="columns">
<div class="column" style="width:60%;">
<p>An executable <strong>binary</strong> (a file on your disk) will be
loaded first into the memory.</p>
<div>
<ul>
<li class="fragment"><p>The <strong>machine instructions</strong> are
loaded into the memory.</p></li>
<li class="fragment"><p>The <span
style="text-decoration-color:#D4E1F5;text-decoration-line: underline;text-decoration-thickness: 0.3rem"><strong>static
data</strong></span> in the binary (i.e.¬†strings etc) is also loaded
into memory.</p></li>
<li class="fragment"><p>The CPU starts fetching the instructions from
the RAM and will start to execute the machine instructions.</p></li>
<li class="fragment"><p>Two memory mechanisms are at play when
executing: the <span
style="text-decoration-color:#FFD966;text-decoration-line: underline;text-decoration-thickness: 0.3rem"><strong>stack</strong></span>
and the <span
style="text-decoration-color:#D40000;text-decoration-line: underline;text-decoration-thickness: 0.3rem"><strong>heap</strong></span></p></li>
</ul>
</div>
<p><strong>Further Technical Videos</strong>: <a
href="https://www.youtube.com/watch?v=7ge7u5VUSbE" target="_blank">A
program is not a process</a>, <a
href="https://www.youtube.com/watch?v=ioJkA7Mw2-U" target="_blank">Why
is the heap so slow</a>, <a
href="https://www.youtube.com/watch?v=N3o5yHYLviQ" target="_blank">Why
is the stack so fast</a>.</p>
</div><div class="column center-content">
<figure>
<img
data-src="presentations/part-1/assets/images/convert/presentations/part-1/assets/images/A1-memory-expanded.svg"
alt="Memory Layout" />
<figcaption aria-hidden="true">Memory Layout</figcaption>
</figure>
</div>
</div>
<!-- prettier-ignore-end -->
</section>
<section id="stack" class="slide level2">
<h2>Stack</h2>
<!-- prettier-ignore-start -->
<div class="columns">
<div class="column" style="width:60%;">
<p>Continuous areas of memory for local variables in functions.</p>
<div>
<ul>
<li class="fragment"><p>It is fixed in size (from start and OS
dependant).</p></li>
<li class="fragment"><p>Stack grows and shrinks, it follows
<strong>function calls</strong>. Each function has its own stack frame
for all its local variables.</p></li>
<li class="fragment"><p>Variables must have <strong>fixed sizes known at
compile time</strong>. (If the compiler doesn‚Äôt know it cannot compute
the stack frame size)</p></li>
<li class="fragment"><p>Access is extremely fast: offset the
<strong>stack pointer</strong>.</p></li>
<li class="fragment"><p>Great memory locality Ó™ú CPU caches.</p></li>
</ul>
</div>
</div><div class="column center-content">
<figure>
<img
data-src="presentations/part-1/assets/images/convert/presentations/part-1/assets/images/A1-memory-expanded.svg"
alt="Memory Layout" />
<figcaption aria-hidden="true">Memory Layout</figcaption>
</figure>
</div>
</div>
<!-- prettier-ignore-end -->
</section>
<section id="stack---example" class="slide level2">
<h2>Stack - Example</h2>
<pre class="rust" data-line-numbers="|9-11|1-7|2-3|5-6||2,5|"><code>fn foo() { // Enter 2. stack frame.
    let a: u32 = 10; // `a` points on the stack containing 10.
    println!(&quot;a address: {:p}&quot;, &amp;a);

    let b: u32 = a;  // Copy `a` to `b`.
    println!(&quot;b address: {:p}&quot;, &amp;b);
} // `a,b` out of scope, we leave the stack frame.

fn main() { // Enter 1. stack frame.
  foo()
}</code></pre>
<p>Stack frame for <code>foo</code> needs at least <span
class="math inline">\(2 \cdot 32\)</span> bits = <span
class="math inline">\(2 \cdot 4\)</span> bytes = <span
class="math inline">\(8\)</span> bytes.</p>
<pre class="text"><code>a address: 0x7ffdb6f09c08
b address: 0x7ffdb6f09c0c  // 08 + 4bytes = 0c</code></pre>
<aside class="notes">
<ul>
<li><p>First look at the execution flow of this program.</p></li>
<li><p>We enter the <code>main</code> function which calls
<code>foo</code>.</p></li>
<li><p>We enter <code>foo</code>, the second stack frame.</p></li>
<li><p>We create a local variable with value <code>10</code> and print
its memory address.</p></li>
<li><p>We create a local variable <code>b</code> by assigning
<code>a</code> which copies the value from <code>a</code> to
<code>b</code>, and we print its memory address.</p></li>
<li><p>Lets look now from the compiler what it does.</p></li>
<li><p>When the compiler compiles this program to machine instruction,
it sees that function <code>foo</code> needs two 32bit variables, so the
machine code in function <code>foo</code> will operate on a stack frame
with exactly that size (namely 64 bits), to store <code>a</code> and
<code>b</code> essentially for the instructions on line</p></li>
<li><p>2 and</p></li>
<li><p>5</p></li>
</ul>
</aside>
</section>
<section id="the-heap-1" class="slide level2">
<h2>The Heap (1)</h2>
<p>The <strong>heap</strong> is just one <strong>big pile of
memory</strong> for dynamic memory allocation.</p>
<div class="fragment">
<h3 id="usage">Usage</h3>
<div>
<ul>
<li class="fragment"><p>Memory which outlives the stack (when you leave
the function).</p></li>
<li class="fragment"><p>Storing <strong>big objects</strong> in memory
is done using <strong>the heap</strong>.</p></li>
</ul>
</div>
</div>
</section>
<section id="the-heap-2" class="slide level2">
<h2>The Heap (2)</h2>
<p>The memory <strong>management</strong> on the <strong>heap depends on
the language</strong> you write.</p>
<!-- prettier-ignore-start -->
<div class="fragment">
<h3 id="mechanics">Mechanics</h3>
<div>
<ul>
<li class="fragment"><p><strong>Allocation/deallocation</strong> on the
heap is done by the operating system.</p>
<ul>
<li class="fragment">Linux: Programs will call into <code>glibc</code>
(<code>malloc</code> , etc.) which interacts with the kernel.</li>
</ul></li>
<li class="fragment"><p><strong>Depends on the language</strong>:</p>
<div class="columns">
<div class="column" style="width:50%;">
<ul>
<li class="fragment"><span class="red"><strong>Full
Control</strong></span>: C, C++, Pascal,‚Ä¶:
<ul>
<li class="fragment">Programmer decides when to allocate and deallocate
memory.</li>
<li class="fragment">Programmer ensures if some pointer still points to
valid memory Ó™ú üöÄ vs.¬†üí£üêû</li>
</ul></li>
</ul>
</div><div class="column" style="width:50%;">
<ul>
<li class="fragment"><span class="green"><strong>Full
Safety</strong></span>: Java, Python, Go, Haskell, ‚Ä¶:
<ul>
<li class="fragment">A runtime system (<strong>garbage
collector</strong>) ensures memory is deallocated at the right time. Ó™ú
üêå vs.¬†ü¶∫</li>
</ul></li>
</ul>
</div>
</div></li>
</ul>
</div>
</div>
<!-- prettier-ignore-end -->
</section>
<section class="slide level2">

<h3 id="mechanics-1">Mechanics ü¶Ä</h3>
<ul>
<li><p><span class="green"><strong>Full Control and
Safety</strong></span>: <strong>Rust</strong> - <span class="emph">Via
compile time enforcement of correct memory management.</span></p>
<ul>
<li>It does this with an explicit ownership concept.</li>
<li>It tracks life times (of references).</li>
</ul></li>
</ul>
</section>
<section id="variable-scoping-recap" class="slide level2">
<h2>Variable Scoping (recap)</h2>
<pre class="rust"><code>fn main() {
    let i: u32 = 10; // `i` in scope.

    if i &gt; 5 {
        let j = i;
    }  // `j` no longer in scope.

    println!(&quot;i = {}&quot;, i);
} // i is no longer in scope</code></pre>
<ul>
<li>Types of <code>i</code> and <code>j</code> are examples of a
<code>Copy</code> types.</li>
<li>What if copying is too expensive?</li>
</ul>
<aside class="notes">
<ul>
<li>When looking at how Rust solves working with the heap, we have to
know a little bit about variable scoping.</li>
<li>In Rust, every variable has a scope, that is, a section of the code
that that variable is valid for. Note that this is a bit different from
python.</li>
<li>In our example we have <code>i</code> and <code>j</code>. Note how
we can just create a copy by assigning <code>i</code> to
<code>j</code>.</li>
<li>Here the type of i and j is actually known as a <code>Copy</code>
type.</li>
<li>But sometimes there is data that would be way too much to Copy
around every time, it would make our program slow.</li>
</ul>
</aside>
</section>
<section id="ownership-1" class="slide level2">
<h2>Ownership (1)</h2>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" data-line-numbers=""><code>// Create a variable on the stack.
let a = 5;</code></pre>
<p>Local integer <code>a</code> allocated on the <br>
<strong>stack</strong>.</p>
<p><img
data-src="presentations/part-1/assets/images/convert/presentations/part-1/assets/images/convert/62755b0778c14733fa2bc6f02578ffe63e32165c.svg"
class="svgbob" /></p>
</div><div class="column fragment" style="width:50%;">
<pre class="rust" data-line-numbers=""><code>// Create an owned, heap allocated string
let a = String::from(&quot;hello&quot;);</code></pre>
<p>Strings (<code>a</code>) store data on the <strong>heap</strong>
because they <strong>can grow</strong>.</p>
<p><img
data-src="presentations/part-1/assets/images/convert/presentations/part-1/assets/images/convert/5af8adc0f625c7c413a72a0e9afcec84973c0414.svg"
class="svgbob" /></p>
</div>
</div>
</section>
<section class="slide level2">

<h3 id="ownership-2">Ownership (2)</h3>
<!-- prettier-ignore-start -->
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" data-line-numbers="3"><code>fn foo() {
  let a = 5;
  let b = a;
}</code></pre>
<p><span class="fragment">Assignment of <code>a</code> to <code>b</code>
<strong>copies</strong> <code>a</code> to <code>b</code>.</span></p>
<div class="center-content p-no-margin fragment">
<p><img
data-src="presentations/part-1/assets/images/convert/presentations/part-1/assets/images/convert/faa731e7011a32c5e192de4f1d03c1a233a95caf.svg"
class="svgbob" style="margin:0;" /></p>
</div>
</div><div class="column fragment" style="width:50%;">
<pre class="rust" data-line-numbers="3"><code>fn foo() {
  let a = String::from(&quot;hello&quot;);
  let b = a;
}</code></pre>
<p><span class="fragment">Assign. <code>a</code> to <code>b</code>
transfers ownership (<strong>move</strong>).</span></p>
<div class="center-content p-no-margin fragment">
<p><img
data-src="presentations/part-1/assets/images/convert/presentations/part-1/assets/images/convert/4a00f19ded22ab246386269343a6feab939a6706.svg"
class="svgbob" style="margin:0;" /></p>
</div>
<div>
<ul>
<li class="fragment">When <code>a</code> out of scope: nothing
happens.</li>
<li class="fragment">When <code>b</code> goes out of scope: the string
<strong>data is deallocated</strong>.</li>
</ul>
</div>
</div>
</div>
<!-- prettier-ignore-end -->
</section>
<section class="slide level2">

<h3 id="ownership-3">Ownership (3)</h3>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" data-line-numbers="4"><code>fn foo() {
  let a = String::from(&quot;hello&quot;);
  let b = a;
  println!(&quot;{}, world!&quot;, a);
  //      Nope!! ‚ùå -----^
}</code></pre>
</div><div class="column fragment" style="width:60%;">
<pre class="text" data-line-numbers="4-8|10-12"
style="font-size:14pt"><code>error[E0382]: borrow of moved value: `a`
--&gt; src/main.rs:4:28
  |
2 |     let a = String::from(&quot;hello&quot;);
  |         - move occurs because `a`
  |           has type `String`, which
  |           does not implement the `Copy`
  |           trait
  |
3 |     let b = a;
  |             - value moved here
4 |     println!(&quot;{}, world!&quot;, a);
  |                            ^
  |            value borrowed here
  |            after move</code></pre>
</div>
</div>
</section>
<section id="ownership---the-rules" class="slide level2">
<h2>Ownership - The Rules</h2>
<div>
<ul>
<li class="fragment"><p>There is always <strong>ever only one
owner</strong> of a stack value.</p></li>
<li class="fragment"><p>Once the owner goes out of scope (and is removed
from the stack), any associated values on <strong>the heap</strong> will
be deallocated.</p></li>
<li class="fragment"><p>Rust <strong>transfers ownership</strong> for
non-copy types: <strong>move semantics</strong>.</p></li>
</ul>
</div>
<div class="center-content p-no-margin">
<p><img
data-src="presentations/part-1/assets/images/convert/presentations/part-1/assets/images/A1-i-own-this-light-mod.png" /></p>
</div>
<aside class="notes">
<ul>
<li>What we‚Äôve just seen is the Rust ownership system in action.</li>
<li>In Rust, every part of memory in use always has an owner variable.
That variable must always be the only owner, there can‚Äôt be multiple
owners.</li>
<li>Once a scope that contains a variable ends we don‚Äôt just pop the top
from the stack, but we also clean up any associated values on the
heap.</li>
<li>We can safely do this because we just said that this variable was
the only owner of that part of memory.</li>
<li>Assigning a variable to another one actually moves ownership to the
other variable and removes it from the first variable, instead of
aliasing it (which is what C and C++ do)</li>
</ul>
</aside>
</section>
<section id="ownership---move-into-function" class="slide level2">
<h2>Ownership - Move into Function</h2>
<!-- prettier-ignore-start -->
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" data-line-numbers="2|4|9-11|5-6"><code>fn main() {
  let a = String::from(&quot;hello&quot;);

  let len = calc_length(a);
  println!(&quot;Length of &#39;{}&#39; is {}.&quot;,
           a, len);
}

fn calc_length(s: String) -&gt; usize {
  s.len()
}</code></pre>
<p><span class="fragment">What will happen when we print on line
5?</span></p>
</div><div class="column fragment" style="width:50%;">
<pre class="text"><code>error[E0382]: borrow of moved value: `a`
--&gt; src/main.rs:4:43
  |
2 | let a = String::from(&quot;hello&quot;);
  |     - move occurs because `a`
  |       has type `String`,
  |       which does not implement the
  |       `Copy` trait
  |
3 | let len = calc_length(a);
  |      value moved here -
  |
4 | println!(&quot;Length of &#39;{}&#39; is {}.&quot;,
  |          a, len);
  |          ^
  |          value borrowed here after move</code></pre>
</div>
</div>
<!--prettier-ignore-end -->
<aside class="notes">
<ul>
<li>Moving also works when calling a function, the function takes
ownership of the variable that is passed to it</li>
<li>That means that when the function ends it will go out of scope and
should be cleaned up</li>
<li>What do you think that will happen in this case when we try and
print the string and the length of the string after the function
call.</li>
</ul>
</aside>
</section>
<section id="ownership---moving-out-of-function" class="slide level2">
<h2>Ownership - Moving Out of Function</h2>
<p>We can return a value to move it out of the function</p>
<div class="columns">
<div class="column" style="width:60%;">
<pre class="rust" data-line-numbers="8-10"><code>fn main() {
    let a = String::from(&quot;hello&quot;);
    let (len, a) = calc_length(a);

    println!(&quot;Length of &#39;{}&#39; is {}.&quot;, a, len);
}

fn calc_length(s: String) -&gt; (usize, String) {
    (s.len(), s)
}</code></pre>
</div><div class="column" style="width:40%;">
<pre class="text fragment"><code>Compiling playground v0.0.1
Finished dev ...
Running `target/debug/playground`

Length of &#39;hello&#39; is 5.</code></pre>
</div>
</div>
<aside class="notes">
<ul>
<li>But what if we move a value into a function and we still want to use
it afterwards, we could choose to move it back at the end of the
function, but it really doesn‚Äôt make for very nice code</li>
<li>Note that Rust allows us to return multiple values from a function
with this syntax.</li>
</ul>
</aside>
</section>
<section id="clone" class="slide level2">
<h2>Clone</h2>
<div class="columns">
<div class="column" style="width:80%; align-content:center;">
<ul>
<li>Many types in Rust are <code>Clone</code>-able.</li>
</ul>
<div>
<ul>
<li class="fragment">Use <code>clone()</code> to create an
<strong>explicit</strong> clone.
<ul>
<li class="fragment">In contrast to <code>Copy</code> which creates an
<strong>implicit</strong> copy.</li>
</ul></li>
<li class="fragment">‚è±Ô∏è Clones can be expensive and could take a long
time, so be careful.</li>
<li class="fragment">üêå Not very efficient if a clone is short-lived
like in this example .</li>
</ul>
</div>
</div><div class="column p-no-margin"
style="width:20%; align-content:center;">
<!-- prettier-ignore-start-->
<p><span class="center-content" style="width:100%;"><img
data-src="presentations/part-1/assets/images/convert/presentations/part-1/assets/images/A1-clone.svg"
class="border-dark" /></span> <!-- prettier-ignore-end --></p>
</div>
</div>
<pre class="rust" data-line-numbers="3"><code>fn main() {
    let x = String::from(&quot;hellothisisaverylongstring...&quot;);
    let len = get_length(x.clone());
    println!(&quot;{}: {}&quot;, x, len);
}

fn get_length(s: String) -&gt; usize {
    s.len()
}</code></pre>
<aside class="notes">
<ul>
<li>There is something else in Rust</li>
<li>Many types implement a way to create an explicit copy, such types
are clone-able. But note how we have to very explicitly say that we want
a clone.</li>
<li>Such a clone is a full deep copy clone and can of course take a long
time, which is why Rust wants you to be explicit.</li>
<li>Also in this example this is a really inefficient usage of our
clone, because it gets destroyed almost immediately after creation</li>
</ul>
</aside>
</section>
<section id="clone-explicitness-vs.-python" class="slide level2">
<h2>Clone Explicitness vs.¬†Python</h2>
<p>In contrast to Rust, <code>python</code> hides when stuff gets copied
or referenced:</p>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="python" data-line-numbers="3-4"><code># Python
a = 1
b = a
b += 1
print(a) # `a` is unchanged
         #  -&gt; `int` is a copy-type.</code></pre>
</div><div class="column" style="width:50%;">
<pre class="python" data-line-numbers="3-4"><code># Python
a = {&#39;a&#39;: 1}
b = a    # `b` is a reference to `a`.
b[&#39;a&#39;] += 1
print(a) # `a` is 2
         #  -&gt; dict is reference-counted.</code></pre>
</div>
</div>
</section>
<section id="exercise-time-2" class="slide level2">
<h2>Exercise Time (2)</h2>
<p>Approx. Time: 20-30 min.</p>
<p>Do the following exercises:</p>
<ul>
<li><code>move-semantics</code>: all</li>
</ul>
<p><strong>Build/Run/Test:</strong></p>
<pre class="bash"><code>just build &lt;exercise&gt; --bin 01
just run &lt;exercise&gt; --bin 01
just test &lt;exercise&gt; --bin 01
just watch [build|run|test|watch] &lt;exercise&gt; --bin 01</code></pre>
<!-- markdownlint-disable-file MD034 MD033 MD001 MD024 MD026-->
</section></section>
<section>
<section id="ownership-and-borrowing" class="title-slide slide level1">
<h1>Ownership and Borrowing</h1>

</section>
<section id="ownership" class="slide level2">
<h2>Ownership</h2>
<p>We previously talked about ownership:</p>
<div>
<ul>
<li class="fragment">There is always a <strong>single owner</strong> for
each <strong>stack value</strong>.</li>
<li class="fragment">If <strong>owner</strong> goes out of scope any
associated values is cleaned up.</li>
<li class="fragment">Copy types (<code>Copy</code> trait) creates
<strong>copies</strong>, all other types are
<strong><em>moved</em></strong>.</li>
</ul>
</div>
<aside class="notes">
<ul>
<li>Note once more that the idea of moving is something that exists in
the Rust world, but not necessarily every move actually copies bytes
around, these are all things where Rust‚Äôs model is an abstraction over
what the compiled code actually does.</li>
</ul>
</aside>
</section>
<section id="moving-out-of-a-function" class="slide level2">
<h2>Moving Out of a Function</h2>
<p>We have previously seen this example:</p>
<pre class="rust"><code>fn main() {
    let a = String::from(&quot;hello&quot;);
    let len = calc_length(a);

    println!(&quot;Length of &#39;{}&#39; is {}.&quot;, a, len);
}

fn calc_length(s: String) -&gt; usize {
    s.len()
}</code></pre>
<ul>
<li>Does not compile ‚áí ownership of <code>a</code> is moved into
<code>calc_length</code> ‚áí no longer available in
<code>main</code>.</li>
<li>We can use <code>Clone</code> to create an explicit copy.</li>
<li>We can give ownership back by returning the value.</li>
</ul>
<p><strong>Question: Are there other options?</strong></p>
</section>
<section id="moving-out-of-a-function-1" class="slide level2">
<h2>Moving Out of a Function (üêç)</h2>
<p>In Python we have this:</p>
<pre class="python" data-line-numbers="|8,9"
data-fragment-index="1"><code>def main() {
    a = &quot;hello&quot;;
    l = calc_length(a);

    print(f&quot;Length of &#39;{a}&#39; is {l}.&quot;);
}

def calc_length(s: str) -&gt; int {
    return len(s)
}</code></pre>
<p><span class="fragment"
data-fragment-index="2"><strong>Question:</strong> To what memory does
<code>s</code> refer to? Is it a copy?</span></p>
</section>
<section id="borrowing" class="slide level2">
<h2>Borrowing</h2>
<ul>
<li><p><strong>Analogy:</strong> if somebody owns something you can
<strong>borrow</strong> it from them, but eventually you have to give it
back.</p></li>
<li><p>If a value is <strong>borrowed</strong>, it is <strong>not
moved</strong> and the ownership stays with the original owner.</p></li>
<li><p>To <strong>borrow</strong> in Rust, we create a
<strong><em>reference</em> with <code>&amp;</code>:</strong></p></li>
</ul>
<pre class="rust" data-line-numbers="all|3|8-10|all"><code>fn main() {
    let x = String::from(&quot;hello&quot;);
    let len = get_length(&amp;x); // borrow with &amp;

    println!(&quot;{}&quot;, x);
}

fn get_length(s: &amp;String) -&gt; usize {
    s.len()
}</code></pre>
</section>
<section id="shared-references" class="slide level2">
<h2>Shared References</h2>
<p>Create a <em>shared</em> (<strong>read-only</strong> or immutable)
reference <code>&amp;</code>:</p>
<!-- prettier-ignore-start -->
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" data-line-numbers="2|3|8|5"><code>fn main() {
    let s = String::from(&quot;hello&quot;);
    change(&amp;s);

    println!(&quot;{}&quot;, s);
}

fn change(s: &amp;String) {
    s.push_str(&quot;, world&quot;);
}</code></pre>
</div><div class="column fragment" style="width:50%;">
<pre class="text"><code>error[E0596]:
    cannot borrow `*s` as mutable,
    as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
8 | fn change(s: &amp;String) {
  |              -------
  |     help: consider changing this to
  |            be a mutable reference:
  |           `&amp;mut String`
9 |     s.push_str(&quot;, world&quot;);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |     `s` is a `&amp;` reference, so the data
  |     it refers to cannot be borrowed
  |     as mutable

For more information about this error,
try `rustc --explain E0596`.</code></pre>
</div>
</div>
<!-- prettier-ignore-end -->
<aside class="notes">
<ul>
<li>Note how we cannot modify the referenced value through an immutable
reference</li>
</ul>
</aside>
</section>
<section id="exclusive-references" class="slide level2">
<h2>Exclusive References</h2>
<p>Create an <em>exclusive</em> (<strong>writable</strong> or mutable)
reference <code>&amp;mut</code>:</p>
<!-- prettier-ignore-start -->
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" data-line-numbers="|3,8"
data-fragment-index="1"><code>fn main() {
    let mut s = String::from(&quot;hello&quot;);
    change(&amp;mut s);

    println!(&quot;{}&quot;, s);
}

fn change(s: &amp;mut String) {
    s.push_str(&quot;, world&quot;);
}</code></pre>
</div><div class="column fragment" style="width:50%;">
<pre class="text"><code>Compiling playground v0.0.1 (/playground)
Finished dev target(s) in 2.55s
Running `target/debug/playground`
hello, world</code></pre>
</div>
</div>
<!-- prettier-ignore-end -->
<div data-fragment-index="4">
<ul>
<li class="fragment"><p>A <strong>write</strong> reference can even
fully replace the original value.</p></li>
<li class="fragment"><p>Use the dereference operator (<code>*</code>) to
modify the value:</p>
<pre class="rust"><code>*s = String::from(&quot;Goodbye&quot;);</code></pre></li>
</ul>
</div>
<aside class="notes">
<ul>
<li>We can use a mutable reference here to allow us to modify a borrowed
value</li>
<li>Note that you may also sometimes have to use the deref operator to
access the value when reading it, but most of the time the Rust compiler
will do this automatically and you need not worry about it.</li>
</ul>
</aside>
</section>
<section id="rules-for-borrowing-and-references" class="slide level2">
<h2>Rules for Borrowing and References</h2>
<p>To any value, you can either have <strong>at the same
time</strong>:</p>
<div class="columns">
<div class="column fragment" style="width:50%;">
<h3 id="references">References</h3>
<ul>
<li>A single <strong>write reference <code>&amp;mut T</code></strong>
üñäÔ∏è</li>
</ul>
<p><strong>OR</strong></p>
<ul>
<li>Many <strong>read references <code>&amp;T</code></strong> üìë üìë
üìë</li>
</ul>
</div><div class="column fragment" style="width:50%;">
<h3 id="lifetime">Lifetime</h3>
<ul>
<li>References <strong>cannot live</strong> longer than their
owners.</li>
<li>A reference will always at all times <strong>point to a valid
value</strong>.</li>
</ul>
</div>
</div>
<p><span class="fragment emph">These rules are enforced by the
<strong>borrow checker</strong>.</span></p>
<aside class="notes">
<ul>
<li>Rust tries to be smart about enforcing these rules, such that you
don‚Äôt notice them that often in real life usage, but there may be some
cases that clearly appear valid, but Rust won‚Äôt allow. There are
generally pretty easy workarounds though.</li>
<li>Again: references are not pointers, but in practice of course they
do look similar and are implemented the same way, but Rust‚Äôs memory
model is not the same as that of C/C++ and implementation is not the
same as our model.</li>
<li>Think about the second rule : This will enable lock-free
parallelization!</li>
</ul>
</aside>
</section>
<section id="borrowing-and-memory-safety" class="slide level2">
<h2>Borrowing and Memory Safety</h2>
<ul>
<li><p>The ownership model does guarantee <strong>no</strong>: <br> null
pointer dereferences, data races, dangling pointers, use after
free.</p></li>
<li><p>ü¶∫ Rust is memory safe without any runtime garbage
collector.</p></li>
<li><p>üöÄ Performance of a language that would normally let you manage
memory manually.</p></li>
</ul>
<aside class="notes">
<ul>
<li>Memory bugs such as: null pointer dereferences, data races, dangling
pointers, use after free.</li>
</ul>
</aside>
</section>
<section id="borrow-checkers-scope" class="slide level2">
<h2>Borrow Checker‚Äôs Scope</h2>
<div class="columns">
<div class="column p-no-margin" style="width:50%;">
<figure id="fig:borrow-checkers-scope">
<img
data-src="presentations/part-1/assets/images/convert/presentations/part-1/assets/images/convert/dafcbd1e090d80c3d16f4737da13cfcf8f555357.svg"
class="svgbob" alt="BorrowChecker‚Äôs Scope" />
<figcaption aria-hidden="true">BorrowChecker‚Äôs Scope</figcaption>
</figure>
</div><div class="column" style="width:50%;">
<ul>
<li>There are different facilities in Rust to work around some
limitations of the borrow checker (<em>Interior Mutability</em>
(later)).</li>
</ul>
</div>
</div>
<aside class="notes">

</aside>
</section>
<section id="reference-example" class="slide level2">
<h2>Reference Example</h2>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" data-line-numbers="|3,5"><code>fn main() {
    let mut s = String::from(&quot;hello&quot;);
    let a = &amp;s;
    let b = &amp;s;
    let c = &amp;mut s;
    println!(&quot;{} - {} - {}&quot;, a, b, c);
}</code></pre>
</div><div class="column fragment" style="width:50%;">
<pre class="text"><code>error[E0502]: cannot borrow `s` as mutable
              because it is also
              borrowed as immutable
 --&gt; src/main.rs:5:14
  |
3 |     let a = &amp;s;
  |              - immutable borrow occurs
  |                here
4 |     let b = &amp;s;
5 |     let c = &amp;mut s;
  |              ^^^^^ mutable borrow occurs here
  |
6 |     println!(&quot;{} - {} - {}&quot;, a, b, c);
  |                              ^
  |  immutable borrow later used here

For more information about this error,
try `rustc --explain E0502`.</code></pre>
</div>
</div>
</section>
<section id="returning-references---quiz" class="slide level2">
<h2>Returning References - Quiz</h2>
<p><strong>Question: Does the following work?</strong> <a
href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=c26cf791529a35d2c105c1d5c55022bd"
target="_blank">Link</a></p>
<div class="columns">
<div class="column" style="width:40%;">
<pre class="rust"><code>fn give_me_a_ref() -&gt; &amp;String {
  let s = String::from(&quot;Ups&quot;);
  &amp;s
}</code></pre>
</div><div class="column" style="width:70%;">
<pre class="text fragment" data-line-numbers="|13-15"
style="font-size=14pt"><code>error[E0106]: missing lifetime specifier
1 | fn give_me_a_ref() -&gt; &amp;String {
  |                       ^ expected named
  |                         lifetime parameter
  = help: this function&#39;s return type
        contains a borrowed value,
          but there is no value for it to be borrowed from
help: consider using the `&#39;static` lifetime,
      but this is uncommon unless you&#39;re returning a
      borrowed value from a `const` or a `static`
1 | fn give_me_a_ref() -&gt; &amp;&#39;static String {
  |                        +++++++
help: instead, you are more likely
      to want to return an owned value
1 | fn give_me_a_ref() -&gt; String {</code></pre>
</div>
</div>
<p><span class="fragment"><strong>‚ùóNote: Returning a reference to a
stack value (e.g.¬†<code>s</code>) is not possible.</strong></span></p>
</section>
<section id="returning-references---quiz-1" class="slide level2">
<h2>Returning References - Quiz</h2>
<p>The following is the correct signature:</p>
<pre class="rust fragment"><code>fn give_me_a_value() -&gt; String {
    let s = String::from(&quot;Hello, world!&quot;);
    s
}</code></pre>
</section>
<section id="returning-references" class="slide level2">
<h2>Returning References</h2>
<p>You can however pass a reference through the function:</p>
<pre class="rust"><code>fn give_me_a_ref(input: &amp;(String, i32)) -&gt; &amp;String {
    &amp;input.0
}</code></pre>
<ul>
<li>Rust annotates each reference with a <strong>lifetime</strong>.</li>
<li>How to use lifetimes? Ó™ú later!</li>
</ul>
<aside class="notes">
<p>We will later see how these work if we have to use them to help the
compiler in certain cases.</p>
</aside>
</section>
<section id="exercise-time-3" class="slide level2">
<h2>Exercise Time (3)</h2>
<p>Approx. Time: 20-30 min.</p>
<p>Do the following exercises:</p>
<ul>
<li><code>borrowing</code>: all</li>
</ul>
<p><strong>Build/Run/Test:</strong></p>
<pre class="bash"><code>just build &lt;exercise&gt; --bin 01
just run &lt;exercise&gt; --bin 01
just test &lt;exercise&gt; --bin 01
just watch [build|run|test|watch] &lt;exercise&gt; --bin 01</code></pre>
<!-- markdownlint-disable-file MD034 MD033 MD001 MD024 MD026-->
</section></section>
<section>
<section id="composite-types" class="title-slide slide level1">
<h1>Composite Types</h1>

</section>
<section id="types-redux" class="slide level2">
<h2>Types Redux</h2>
<p>We have seen so far:</p>
<div>
<ul>
<li class="fragment">Primitives (integers, floats, booleans,
characters)</li>
<li class="fragment">Compounds (tuples, arrays)</li>
<li class="fragment">Most of the types we looked at were
<code>Copy</code></li>
</ul>
</div>
<p><span class="fragment">Borrowing will make more sense with some more
<strong>complex data types</strong>.</span></p>
</section>
<section id="structuring-data" class="slide level2">
<h2>Structuring data</h2>
<p>Rust has two important ways to structure data</p>
<ul>
<li><code>struct</code> : <strong>product type</strong></li>
<li><code>enum</code>s : <strong>sum type</strong></li>
<li><del>unions</del></li>
</ul>
<aside class="notes">
<ul>
<li>We have unions in Rust, but almost everywhere you will use enums
instead. Unions become relevant once we start talking about FFI and
unsafe Rust code.</li>
</ul>
</aside>
</section>
<section id="structs-tuple-structs" class="slide level2">
<h2>Structs (<em>tuple structs</em>)</h2>
<p>A tuple <code>struct</code> is similar to a tuple but it has an own
name:</p>
<pre class="rust"><code>struct ControlPoint(f64, f64, bool);</code></pre>
<div class="fragment">
<p>Access to members the same as with tuples:</p>
<pre class="rust"><code>fn main() {
  let cp = ControlPoint(10.5, 12.3, true);
  println!(&quot;{}&quot;, cp.0); // prints 10.5
}</code></pre>
</div>
<aside class="notes">
<ul>
<li>Note that two tuples with the same fields in the same order are
always the same type, whereas two structs with different names but the
same fields are different types.</li>
</ul>
</aside>
</section>
<section id="structs" class="slide level2">
<h2>Structs</h2>
<p>More common (and preferred) - <code>struct</code>s with named
fields:</p>
<pre class="rust"><code>struct ControlPoint {
  x: f64,
  y: f64,
  enabled: bool,
}</code></pre>
<ul>
<li>Each member has a proper identifier.</li>
</ul>
<div>
<pre class="rust" data-line-numbers="all|2-6|8"><code>fn main() {
  let cp = ControlPoint {
    x: 10.5,
    y: 12.3,
    enabled: true,
  };

  println!(&quot;{}&quot;, cp.x); // prints 10.5
}</code></pre>
</div>
<aside class="notes">
<ul>
<li>Named fields are especially easier in usage, as a type alone will
most of the time not be enough information to determine the full
meaning, here we now now that the two floats meant the x and y
coordinates and we know what the boolean indicated.</li>
<li>To instantiate (create a value) of a struct we use the syntax
shown</li>
<li>Now, we can use the same <code>x.y</code> syntax as with tuples, but
we have a nice name for referencing our fields instead of having to
remember the exact field index.</li>
</ul>
</aside>
</section>
<section id="enumerations" class="slide level2">
<h2>Enumerations</h2>
<p>One other powerful type is the <code>enum</code>. It is a <strong>sum
type</strong>:</p>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" data-line-numbers="all|2|all"><code>enum Fruit {
  Banana,
  Apple,
}</code></pre>
</div><div class="column fragment" data-fragment-index="2"
style="width:50%;">
<pre class="rust"><code>fn main() {
  let fruit = Fruit::Banana;
}</code></pre>
</div>
</div>
<ul>
<li><p>An enumeration has different <em>variants</em>,
<code>python</code> analogy:</p>
<pre class="python"><code>variant: str | int | List[str]</code></pre></li>
<li><p>Each variant is an alternative value of the <code>enum</code>,
pick a value on creation.</p></li>
</ul>
</section>
<section id="enumeration---mechanics" class="slide level2">
<h2>Enumeration - Mechanics</h2>
<pre class="rust" data-line-numbers=""><code>enum Fruit {
  Banana, // discriminant: 0
  Apple, // discriminant: 1
}</code></pre>
<div>
<ul>
<li class="fragment"><p>Each <code>enum</code> has a
<em>discriminant</em> (hidden by default):</p>
<ul>
<li class="fragment"><p>A numeric value (<code>isize</code> by default,
can be changed by using <code>#[repr(numeric_type)]</code>) to determine
the current variant.</p></li>
<li class="fragment"><p>One cannot rely on the discriminant being
<code>isize</code>, the compiler may decide to optimize it.</p></li>
</ul></li>
</ul>
</div>
</section>
<section id="enumerations---data-1" class="slide level2">
<h2>Enumerations - Data (1)</h2>
<p><code>Enum</code>s are very powerful: each variant can have
associated data</p>
<div class="columns fragment">
<div class="column" style="width:55%;">
<pre class="rust"><code>enum Fruit {
  Banana(u16, u16), // discriminant: 0
  Apple(f32, f32), // discriminant: 1
}</code></pre>
<pre class="rust fragment"><code>fn main() {
  let üçå = Fruit::Banana(3, 2);
  let üçé = Fruit::Apple(3.0, 4.);
}</code></pre>
</div><div class="column" style="align-content:center;">
<ul>
<li>The associated data and the variant are <strong>bound
together</strong>.</li>
<li>Impossible to create <code>Apple</code> only giving <code>u16</code>
integers.</li>
</ul>
<div>
<ul>
<li class="fragment"><p>An <code>enum</code> is as large as the largest
variant + <br> size of the discriminant.</p>
<div class="center-content p-no-margin">
<p><img
data-src="presentations/part-1/assets/images/convert/presentations/part-1/assets/images/convert/aa9b03ca1a5eea8743a8c97e527f75b2f898313d.svg"
class="svgbob" /></p>
</div></li>
</ul>
</div>
</div>
</div>
</section>
<section id="mix-sum-and-product-types" class="slide level2">
<h2>Mix Sum and Product Types</h2>
<p>Combining <strong>sum-type</strong> with a
<strong>product-type</strong>:</p>
<pre class="rust" data-line-numbers="|2,6,11"><code>struct Color {
  rgb: (bool, bool, bool)
}

enum Fruit {
  Banana(Color),
  Apple(bool, bool)
}

fn main() {
  let üçå = Fruit::Banana(Color{rgb: (false,true,false)});
  let üçé = Fruit::Apple(false, true);
}</code></pre>
<p>The type <code>Fruit</code> has <span class="math inline">\((2\cdot 2
\cdot 2) + (2\cdot 2) = 12\)</span> possible states.</p>
</section>
<section id="enumerations---discriminant" class="slide level2">
<h2>Enumerations - Discriminant</h2>
<p>You can control the discriminant like:</p>
<pre class="rust"><code>#[repr(u32)]
enum Bar {
    A, // 0
    B = 10000,
    C, // 10001
}

fn main() {
    println!(&quot;A: {}&quot;, Bar::A as u32);
    println!(&quot;B: {}&quot;, Bar::B as u32);
    println!(&quot;C: {}&quot;, Bar::C as u32);
}</code></pre>
<aside class="notes">
<ul>
<li>See the explicitness of the cast!</li>
</ul>
</aside>
</section>
<section id="exercise-time-4" class="slide level2">
<h2>Exercise Time (4)</h2>
<p>Approx. Time: 20-30 min.</p>
<p>Do the following exercises:</p>
<ul>
<li><code>composite-types</code>: all</li>
</ul>
<p><strong>Build/Run/Test:</strong></p>
<pre class="bash"><code>just build &lt;exercise&gt; --bin 01
just run &lt;exercise&gt; --bin 01
just test &lt;exercise&gt; --bin 01
just watch [build|run|test|watch] &lt;exercise&gt; --bin 01</code></pre>
<!-- markdownlint-disable-file MD034 MD033 MD001 MD024 MD026-->
</section></section>
<section>
<section id="pattern-matching" class="title-slide slide level1">
<h1>Pattern Matching</h1>

</section>
<section id="extracting-data-from-enum" class="slide level2">
<h2>Extracting Data from <code>enum</code></h2>
<ul>
<li>We must ensure we interpret <code>enum</code> data correctly.</li>
<li>Use <strong>pattern matching</strong> to do so.</li>
</ul>
</section>
<section id="pattern-matching-1" class="slide level2">
<h2>Pattern Matching</h2>
<p>Using the <code>if let &lt;pattern&gt; = &lt;expr&gt;</code>
statement:</p>
<pre class="rust" data-line-numbers="2"><code>fn accept_banana(fruit: Fruit) {
  if let Fruit::Banana(a, _) = fruit {
    println!(&quot;Got a banana: {}&quot;, a);
  } else {
    println!(&quot;not handled&quot;)
  }
}</code></pre>
<div>
<ul>
<li class="fragment"><p><code>a</code> is a local variables within
<code>if</code>-body.</p></li>
<li class="fragment"><p>The underscore (<code>_</code>) can be used to
accept any value.</p></li>
<li class="fragment"><p><strong>Note:</strong> Abbreviation for the
above: <a
href="https://doc.rust-lang.org/rust-by-example/flow_control/let_else.html"
target="_blank"><code>let else</code></a>.</p>
<pre class="rust"><code>let Fruit::Banana(a, _) = fruit else { println!(&quot;not handled.&quot;) };</code></pre></li>
<li class="fragment"><p>There is also <a
href="https://doc.rust-lang.org/rust-by-example/flow_control/while_let.html"
target="_blank"><code>while let</code></a>.</p></li>
</ul>
</div>
</section>
<section id="match-statement" class="slide level2">
<h2>Match Statement</h2>
<p>Pattern matching is very powerful if combined with the
<code>match</code> statement:</p>
<div class="columns fragment">
<div class="column" style="width:50%;">
<pre class="rust" data-line-numbers="3|6|9|12"><code>fn accept_fruit(fruit: Fruit) {
  match fruit {
    Fruit::Banana(3) =&gt; {
      println!(&quot;Banana is 3 months old.&quot;);
    },
    Fruit::Banana(v) =&gt; {
      println!(&quot;Banana: age {:?}.&quot;, v)
    }
    Fruit::Apple(true, _) =&gt; {
      println!(&quot;Ripe apple.&quot;);
    },
    _ =&gt; {
      println!(&quot;Wrong fruit...&quot;);
    },
  }
}</code></pre>
</div><div class="column" style="width:30%;">
<pre class="rust"><code>enum Fruit {
  Banana(u8),
  Apple(bool, bool)
}</code></pre>
<ul>
<li><p>Every part of the match is called an arm. First match from top to
bottom wins!</p></li>
<li><p>A <strong>match is exhaustive</strong>, meaning <a
href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=62dc4e2804b91dfc1a7f40f1826fb538"
target="_blank"><strong>all possible values</strong> must be
handled</a></p></li>
<li><p>Use a catch-all <code>_</code> arm for all remaining cases.
<strong>Use deliberately!</strong></p></li>
</ul>
</div>
</div>
</section>
<section id="match-expression" class="slide level2">
<h2>Match Expression</h2>
<p>The match statement can even be used as an expression:</p>
<pre class="rust"><code>fn get_age(fruit: Fruit) {
  let age = match fruit {
    Fruit::Banana(a) =&gt; a,
    Fruit::Apple(_) =&gt; 1, // `_` matches the tuple.
  };

  println!(&quot;The age is: {}&quot;, age);
}</code></pre>
<div>
<ul>
<li class="fragment">All match arms <strong>must return the same
type</strong>.</li>
<li class="fragment">No catch all (<code>_ =&gt;</code>) arm requires
<strong>all cases</strong> handled.</li>
</ul>
</div>
</section>
<section id="complex-match-statements" class="slide level2">
<h2>Complex Match Statements</h2>
<pre class="rust" contenteditable="true"><code>fn main() {
    let input = &#39;x&#39;;
    match input {
        &#39;q&#39;                       =&gt; println!(&quot;Quitting&quot;),
        &#39;a&#39; | &#39;s&#39; | &#39;w&#39; | &#39;d&#39;     =&gt; println!(&quot;Moving around&quot;),
        &#39;0&#39;..=&#39;9&#39;                 =&gt; println!(&quot;Number input&quot;),
        key if key.is_lowercase() =&gt; println!(&quot;Lowercase: {key}&quot;),
        _                         =&gt; println!(&quot;Something else&quot;),
    }
}</code></pre>
<ul>
<li><code>|</code> means <code>or</code>.</li>
<li><code>1..=9</code> is an inclusive range (later!).</li>
</ul>
<p><strong>Quiz:</strong> Why not <code>if key.is_lowercase()</code>
after <code>=&gt;</code> ?</p>
<p><span class="fragment"><strong>Answer:</strong> That would never
print <code>Something else</code>.</span></p>
<!-- markdownlint-disable-file MD034 MD033 MD001 MD024 MD026-->
</section></section>
<section>
<section id="implementation-blocks-impl"
class="title-slide slide level1">
<h1>Implementation Blocks <code>impl</code></h1>

</section>
<section id="implementing-member-functions" class="slide level2">
<h2>Implementing Member Functions</h2>
<p>To associate functions to <code>structs</code> and
<code>enums</code>, we use <code>impl</code> blocks</p>
<pre class="rust"><code>fn main() {
  let x = &quot;Hello&quot;;
  x.len();
}</code></pre>
<ul>
<li>Syntax <code>x.len()</code> similar to field access in
<code>struct</code>s.</li>
</ul>
</section>
<section id="the-impl-block-2" class="slide level2">
<h2>The <code>impl</code> Block (2)</h2>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" data-line-numbers="6-10,14"><code>struct Banana
{
  size: f64;
}

impl Banana {
  fn get_volume(&amp;self) -&gt; f64 {
    return self.size * self.size * 1.5;
  }
}

fn main() {
  let b = Banana{size: 4};
  let v = b.get_volume();
}</code></pre>
</div><div class="column" style="width:50%; align-content:center;">
<ul>
<li><p>Functions can be defined on our types using <code>impl</code>
blocks.</p></li>
<li><p>Implementation blocks possible on any type, not just
<code>struct</code>s (with exceptions).</p></li>
</ul>
</div>
</div>
<aside class="notes">
<ul>
<li>Here we define the get_volume method</li>
<li>Note how the impl block is separate from the type definition.</li>
<li>In fact we can have multiple impl blocks for the same type, as long
as function definitions do not overlap (not useful right now, but it
will be once we get more into generics)</li>
</ul>
</aside>
</section>
<section id="the-self-self-implementation" class="slide level2">
<h2>The <code>self</code> &amp; <code>Self</code>: Implementation</h2>
<ul>
<li><code>self</code> parameter: the <strong><em>receiver</em></strong>
on which a function is defined.</li>
<li><code>Self</code> type: <strong><em>shorthand for the
type</em></strong> of current implementation.</li>
</ul>
<div class="columns">
<div class="column" style="width:55%;">
<pre class="rust" data-line-numbers="all|4|6-8|10|12-14"
style="font-size:14pt"><code>struct Banana { size: f64; }

impl Banana {
    fn new(i: f64) -&gt; Self { Self { size: i } }

    fn consume(self) -&gt; Self {
        Self::new(self.size - 5.0)
    }
    // Take read reference of `Banana` instance.
    fn borrow(&amp;self) -&gt; &amp;f64 { &amp;self.size }
    // Take write reference of `Banana` instance.
    fn borrow_mut(&amp;mut self) -&gt; &amp;mut f64 {
        &amp;mut self.size
    }
}</code></pre>
</div><div class="column" style="width:45%; align-content:center;">
<div>
<ul>
<li class="fragment">Absence of a <code>self</code> parameter means its
an <strong><em>associated function</em></strong> on that type
(e.g.¬†<code>new</code>).</li>
<li class="fragment"><code>self</code> is always first argument and its
always the type on which <code>impl</code> is defined (type not
needed).</li>
<li class="fragment">Prepend <code>&amp;</code> or <code>&amp;mut</code>
to <code>self</code> to indicate that we take a value by reference.</li>
</ul>
</div>
</div>
</div>
</section>
<section id="the-self-self-application" class="slide level2">
<h2>The <code>self</code> &amp; <code>Self</code>: Application</h2>
<div class="columns">
<div class="column" style="width:60%;">
<pre class="rust"><code>struct Banana { size: f64; }

impl Banana {
    fn new(i: f64) -&gt; Self { Self { size: i } }

    fn consume(self) -&gt; Self {
        Self::new(self.size - 5.0)
    }
    // Take read reference of `Banana` instance.
    fn borrow(&amp;self) -&gt; &amp;f64 { &amp;self.size }
    // Take write reference of `Banana` instance.
    fn borrow_mut(&amp;mut self) -&gt; &amp;mut f64 {
        &amp;mut self.size
    }
}</code></pre>
</div><div class="column" style="width:40%;">
<pre class="rust" data-line-numbers="2|3|5|7|8"><code>fn main () {
  let mut f = Banana::new();
  println!(&quot;{}&quot;, f.borrow());

  *f.borrow_mut() = 10;

  let g = f.consume();
  println!(&quot;{}&quot;, g.borrow());
}</code></pre>
</div>
</div>
<!-- markdownlint-disable-file MD034 MD033 MD001 MD024 MD026-->
</section></section>
<section>
<section id="optionals-and-error-handling"
class="title-slide slide level1">
<h1>Optionals and Error Handling</h1>

</section>
<section id="generics" class="slide level2">
<h2>Generics</h2>
<p><code>struct</code>s become more powerful with generics:</p>
<pre class="rust"><code>struct PointFloat(f64, f64);
struct PointInt(i64, i64);</code></pre>
<p><span class="fragment">This is repeating data types ü§®. Is there
something better?</span></p>
<pre class="rust fragment"><code>struct Point&lt;T&gt;(T, T);

fn main() {
  let float_point: Point&lt;f64&gt; = Point(10.0, 10.0);
  let int_point: Point&lt;i64&gt; = Point(10, 10);
}</code></pre>
<p><span class="fragment">Generics are much more powerful (later
more!)</span></p>
<aside class="notes">
<ul>
<li>The upper case letter between the angled brackets introduces a
generic type parameter.</li>
<li>We can now use that generic type variable we introduced as a type
name</li>
<li>Then at the point of using the type we can specify which actual type
we want to use</li>
<li>Generics are much more powerful, but this is enough for now</li>
</ul>
</aside>
</section>
<section id="the-option-type" class="slide level2">
<h2>The <code>Option</code> Type</h2>
<p>A quick look into the <a
href="https://doc.rust-lang.org/std/option/enum.Option.html"
target="_blank">standard library of Rust</a>:</p>
<div>
<ul>
<li class="fragment">Rust does not have <code>null</code> (for good
reasons: ü§¨ üí£ üêû).</li>
<li class="fragment">For types which do not have a value: use
<strong><code>Option&lt;T&gt;</code></strong>.</li>
</ul>
</div>
<pre class="rust fragment"><code>enum Option&lt;T&gt; {
  Some(T),
  None,
}

fn main() {
  let some_int = Option::Some(42);
  let no_string: Option&lt;String&gt; = Option::None; // You need the type here!
}</code></pre>
<aside class="notes">
<ul>
<li>Note how Rust can infer the type of <code>some_int</code>, but we
have to specify what the type of the Option is in the None case, because
it cannot possibly know what kind of values you could put in that
Option</li>
<li>Also not that for normal enums we have to import the variants, but
Option is so common that the variants are available by default without
needing to prefix them with <code>Option::</code></li>
</ul>
</aside>
</section>
<section id="error-handling" class="slide level2"
data-auto-animate="true">
<h2 data-auto-animate="true">Error Handling</h2>
<p>What would we do when there is an error?</p>
<pre class="rust" data-id="devide" data-line-numbers="3"><code>fn divide(x: i64, y: i64) -&gt; i64 {
  if y == 0 {
    // what to do now?
  } else {
    x / y
  }
}</code></pre>
</section>
<section id="error-handling-1" class="slide level2"
data-auto-animate="true">
<h2 data-auto-animate="true">Error Handling</h2>
<p>What would we do when there is an error?</p>
<pre class="rust" data-id="devide" data-line-numbers="3"><code>fn divide(x: i64, y: i64) -&gt; i64 {
  if y == 0 {
    panic!(&quot;Cannot divide by zero&quot;);
  } else {
    x / y
  }
}</code></pre>
<div>
<ul>
<li class="fragment"><p>A <code>panic!</code> in Rust is the most basic
way to handle errors.</p></li>
<li class="fragment"><p>A <code>panic!</code> will <strong>immediately
stop</strong> running the current thread/program using one of two
methods:</p>
<ul>
<li class="fragment"><strong>Unwinding</strong>: Going up through the
stack and making sure that each value is cleaned up.</li>
<li class="fragment"><strong>Aborting</strong>: Ignore everything and
immediately exit the thread/program (OS will clean up).</li>
</ul></li>
</ul>
</div>
<aside class="notes">
<ul>
<li>Unwinding has its usages, mainly to clean up resources that you
previously opened.</li>
<li>An unwind can be stopped, but this is highly unusual to do and very
expensive</li>
<li>In a multithreaded program unwinding is essential to make sure that
any memory owned by that thread is freed, making sure you don‚Äôt have any
memory leaks</li>
<li>Rust programs are compiled that when no panic occurs its fast, but
when one occurs anyway then unwinding happens, but it isn‚Äôt very
fast.</li>
</ul>
</aside>
</section>
<section id="error-handling-with-panic" class="slide level2">
<h2>Error Handling with <code>panic!</code></h2>
<ul>
<li><p>Only use <a href="https://doc.rust-lang.org/std/macro.panic.html"
target="_blank"><code>panic!</code></a> in <strong>small
programs</strong> if normal error handling would also exit the
program.</p></li>
<li><p>‚ùóAvoid using <code>panic!</code> in <strong>library
code</strong> or other <strong>reusable components</strong>.</p></li>
</ul>
<aside class="notes">
<ul>
<li>Generally panicking should be avoided as much as possible</li>
<li>The panic! macro is not the only way to trigger a panic, so beware,
we will see some ways we can also trigger a panic very soon</li>
<li>Note that if the main thread panics, the entire program will always
exit</li>
</ul>
</aside>
</section>
<section id="error-handling-with-optiont" class="slide level2">
<h2>Error Handling with <code>Option&lt;T&gt;</code></h2>
<p>We could use an <a
href="https://doc.rust-lang.org/std/option/enum.Option.html"
target="_blank"><code>Option&lt;T&gt;</code></a> to handle the
error:</p>
<pre class="rust"><code>fn divide(x: i64, y: i64) -&gt; Option&lt;i64&gt; {
  if y == 0 {
    None
  } else {
    Some(x / y)
  }
}</code></pre>
</section>
<section id="error-handling-with-resultte" class="slide level2">
<h2>Error Handling with <code>Result&lt;T,E&gt;</code></h2>
<p>The <a href="https://doc.rust-lang.org/std/result/enum.Result.html"
target="_blank"><code>Result&lt;T,E&gt;</code></a> is a powerful enum
for error handling:</p>
<div class="columns">
<div class="column">
<pre class="rust" data-line-numbers="all|2|3|6-9"><code>enum Result&lt;T, E&gt; {
  Ok(T),
  Err(E),
}

enum DivideError {
  DivisionByZero,
  CannotDivideOne,
}</code></pre>
</div><div class="column fragment">
<pre class="rust fragment" data-line-numbers="all|3|5|7"><code>fn divide(x: i64, y: i64) -&gt; Result&lt;i64, DivideError&gt; {
  if x == 1 {
    Err(DivideError::CannotDivideOne)
  } else if y == 0 {
    Err(DivideError::DivisionByZero)
  } else {
    Ok(x / y)
  }
}</code></pre>
</div>
</div>
</section>
<section id="handling-results" class="slide level2">
<h2>Handling Results</h2>
<p>Handle the error at the call site:</p>
<pre class="rust"><code>fn div_zero_fails() {
  match divide(10, 0) {
    Ok(div) =&gt; println!(&quot;{}&quot;, div),
    Err(e) =&gt; panic!(&quot;Could not divide by zero&quot;),
  }
}</code></pre>
<div>
<ul>
<li class="fragment"><p>Signature of <code>divide</code> function is
<strong>explicit</strong> in how it can fail.</p></li>
<li class="fragment"><p>The user (call site) of it
<strong>decides</strong> what to do, even if it decides to panic
üåª.</p></li>
<li class="fragment"><p><strong>Note:</strong> just as with
<code>Option</code>: <code>Result::Ok</code> and
<code>Result::Err</code> are available globally.</p></li>
</ul>
</div>
<aside class="notes">
<ul>
<li>Note how in this case the error still causes a panic, but at least
we get a choice of what we do</li>
</ul>
</aside>
</section>
<section id="option-vs.-result" class="slide level2">
<h2><code>Option</code> vs.¬†<code>Result</code></h2>
<table>
<thead>
<tr class="header">
<th></th>
<th><code>Option&lt;T&gt;</code></th>
<th><code>Result&lt;T, E&gt;</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Usage</strong></td>
<td>Represent an empty state.</td>
<td>Error handling.</td>
</tr>
<tr class="even">
<td>‚úÖ</td>
<td><code>Some(...)</code></td>
<td><code>Ok(...)</code></td>
</tr>
<tr class="odd">
<td>üõë</td>
<td><code>None</code></td>
<td><code>Err(...)</code></td>
</tr>
</tbody>
</table>
</section>
<section id="handling-results-1" class="slide level2">
<h2>Handling Results</h2>
<p>When prototyping you can use <code>unwrap</code> or
<code>expect</code> on <code>Option</code> and <code>Result</code>:</p>
<pre class="rust" data-line-numbers="2,5"><code>fn div_zero_fails() {
  let div = divide(10, 0).unwrap();
  println!(&quot;{}&quot;, div);

  div = divide(10, 0).expect(&quot;should work!&quot;);
  println!(&quot;{}&quot;, div);
}</code></pre>
<div>
<ul>
<li class="fragment"><p><code>unwrap</code>: return <code>x</code> in
<code>Ok(x)</code> or <code>Some(x)</code> or <code>panic!</code> if
<code>Err(e)</code>.</p></li>
<li class="fragment"><p><code>expect</code> the same but with a
message.</p></li>
<li class="fragment"><p><strong>To many</strong> <code>unwraps</code> is
generally a bad practice.</p></li>
<li class="fragment"><p>If ensured an error won‚Äôt occur, using
<code>unwrap</code> is a good solution.</p></li>
</ul>
</div>
</section>
<section id="handling-results-2" class="slide level2">
<h2>Handling Results</h2>
<p>Rust has lots of helper functions on <code>Option</code> and
<code>Result</code>:</p>
<pre class="rust"><code>fn div_zero_fails() {
  let div = divide(10, 0).unwrap_or(-1);
  println!(&quot;{}&quot;, div);
}</code></pre>
<p>Besides <code>unwrap</code>, there are some other useful utility
functions</p>
<div>
<ul>
<li class="fragment"><code>unwrap_or(val)</code>: If there is an error,
use the value given to <code>unwrap_or</code> instead.</li>
<li class="fragment"><code>unwrap_or_default()</code>: Use the default
value for that type if there is an error (<code>Default</code>).</li>
<li class="fragment"><code>unwrap_or_else(fn)</code>: Same as
<code>unwrap_or</code>, but instead call a function <code>fn</code> that
generates a value in case of an error.</li>
</ul>
</div>
<aside class="notes">
<ul>
<li>unwrap_or_else is mainly useful if generating a default value is an
expensive operation</li>
</ul>
</aside>
</section>
<section id="the-magic-operator" class="slide level2"
data-auto-animate="true">
<h2 data-auto-animate="true">The Magic <code>?</code> Operator</h2>
<p>There is a special operator associated with <code>Result</code>, the
<a
href="https://doc.rust-lang.org/std/result/index.html#the-question-mark-operator-"
target="_blank"><strong><code>?</code> operator</strong></a></p>
<p><span class="fragment">See how this function changes if we use the
<code>?</code> operator:</span></p>
<pre class="rust fragment" data-id="operator"
data-line-numbers="all|2-4|7-10"><code>fn can_fail() -&gt; Result&lt;i64, DivideError&gt; {
  let num: i32 = match divide(10, 1) {
    Ok(v) =&gt; v,
    Err(e) =&gt; return Err(e),
  };

  match divide(num, 2) {
    Ok(v) =&gt; Ok(v * 2),
    Err(e) =&gt; Err(e),
  }
}</code></pre>
</section>
<section id="the-magic-operator-1" class="slide level2"
data-auto-animate="true">
<h2 data-auto-animate="true">The Magic <code>?</code> Operator</h2>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust"><code>fn can_fail() -&gt; Result&lt;i64, DivideError&gt; {
  let num: i32 = match divide(10, 1) {
    Ok(v) =&gt; v,
    Err(e) =&gt; return Err(e),
  };

  match divide(num, 2) {
    Ok(v) =&gt; Ok(v * 2),
    Err(e) =&gt; Err(e),
  }
}</code></pre>
</div><div class="column" style="width:50%;">
<pre class="rust" data-id="operator" data-line-numbers="2|7"><code>fn can_fail() -&gt; Result&lt;i64, DivideError&gt; {
  let num = divide(10, 1)?;




  Ok(divide(num, 2)? * 2)



}</code></pre>
</div>
</div>
<ul>
<li><p>The <code>?</code> operator does an <em>implicit match</em>:</p>
<div>
<ul>
<li class="fragment"><p><strong>on</strong> <code>Err(e)</code> Ó™ú
<code>e</code> is <strong>immediately returned</strong> (early
return).</p></li>
<li class="fragment"><p><strong>on</strong> <code>Ok(v)</code> Ó™ú the
value <code>v</code> is extracted and it contiues.</p></li>
</ul>
</div></li>
</ul>
</section>
<section id="exercise-time-5" class="slide level2">
<h2>Exercise Time (5)</h2>
<p>Approx. Time: 20-1.5h min.</p>
<p>Do the following exercises:</p>
<ul>
<li><code>options</code> (short)</li>
<li><code>error-handling</code> (longer)</li>
<li><code>error-propagation</code> (longer)</li>
</ul>
<p><strong>Build/Run/Test:</strong></p>
<pre class="bash"><code>just build &lt;exercise&gt; --bin 01
just run &lt;exercise&gt; --bin 01
just test &lt;exercise&gt; --bin 01
just watch [build|run|test|watch] &lt;exercise&gt; --bin 01</code></pre>
<!-- markdownlint-disable-file MD034 MD033 MD001 MD024 MD026-->
</section></section>
<section>
<section id="the-type-vect" class="title-slide slide level1">
<h1>The Type <code>Vec&lt;T&gt;</code></h1>

</section>
<section id="vect-storage-for-same-type-t" class="slide level2">
<h2><code>Vec&lt;T&gt;</code>: Storage for Same Type <code>T</code></h2>
<p>The <code>Vec&lt;T&gt;</code> is an array of types <code>T</code>
that <strong>can grow</strong>.</p>
<ul>
<li><p>Compare this to the array, which has a fixed size:</p>
<pre class="rust" data-line-numbers=""><code>fn main() {
  let arr = [1, 2];
  println!(&quot;{:?}&quot;, arr);

  let mut nums = Vec::new();
  nums.push(1);
  nums.push(2);

  println!(&quot;{:?}&quot;, nums);
}</code></pre></li>
</ul>
</section>
<section id="vec-constructor-macro" class="slide level2">
<h2><code>Vec</code>: Constructor Macro</h2>
<p><code>Vec</code> is common type. Use the macro <code>vec!</code> to
initialize it with values:</p>
<pre class="rust" data-line-numbers="2"><code>fn main() {
  let mut nums = vec![1, 2];
  nums.push(3);

  println!(&quot;{:?}&quot;, nums);
}</code></pre>
</section>
<section id="vec-memory-layout" class="slide level2">
<h2><code>Vec</code>: Memory Layout</h2>
<p>How can a vector grow? Things on the stack need to be of a fixed
size.</p>
<div class="columns">
<div class="column fragment" style="width:50%;">
<figure>
<img
data-src="presentations/part-1/assets/images/convert/presentations/part-1/assets/images/convert/6f703db0ddaf383a46dcc0ed49cf275ee38bd502.svg"
class="svgbob" alt="Vec&lt;T&gt; Memory Layout" />
<figcaption aria-hidden="true"><code>Vec&lt;T&gt;</code> Memory
Layout</figcaption>
</figure>
</div><div class="column fragment"
style="width:50%; align-content:center;">
<div>
<ul>
<li class="fragment"><p>A <code>Vec</code> allocates its contents on the
heap (a <code>[i64; 4]</code> is on the stack).</p></li>
<li class="fragment"><p><strong>Quiz:</strong> What happens if the
capacity is full and we add another element.</p>
<ul>
<li class="fragment">The <code>Vec</code> <strong>reallocates</strong>
its memory with more capacity to another memory location Ó™ú Lots of
copies üêå ‚è±Ô∏è.</li>
</ul></li>
</ul>
</div>
</div>
</div>
<!-- markdownlint-disable-file MD034 MD033 MD001 MD024 MD026-->
</section></section>
<section>
<section id="slices" class="title-slide slide level1">
<h1>Slices</h1>

</section>
<section id="vectors-and-arrays" class="slide level2"
data-auto-animate="true">
<h2 data-auto-animate="true">Vectors and Arrays</h2>
<p>Lets write a <code>sum</code> function for arrays
<code>[i64; 10]</code>:</p>
<pre class="rust" data-id="sum" data-line-numbers=""><code>fn sum(data: &amp;[i64; 10]) -&gt; i64 {
  let mut total = 0;

  for val in data {
    total += val;
  }

  total
}</code></pre>
</section>
<section id="vectors-and-arrays-1" class="slide level2"
data-auto-animate="true">
<h2 data-auto-animate="true">Vectors and Arrays</h2>
<p>Or one for just vectors:</p>
<pre class="rust" data-id="sum" data-line-numbers=""><code>fn sum(data: &amp;Vec&lt;i64&gt;) -&gt; i64 {
  let mut total = 0;

  for val in data {
    total += val;
  }

  total
}</code></pre>
</section>
<section id="slices-1" class="slide level2">
<h2>Slices</h2>
<p>There is better way.</p>
<p>Slices are typed as <code>[T]</code>, where <code>T</code> is the
type of the elements in the slice.</p>
<h3 id="properties">Properties</h3>
<div>
<ul>
<li class="fragment"><p>A <strong>slice</strong> is a dynamically sized
view into a <strong>contiguous sequence</strong>.</p></li>
<li class="fragment"><p><strong>Contiguous</strong>: elements in memory
are evenly spaced.</p></li>
<li class="fragment"><p><strong>Dynamically Sized</strong>: the size of
the slice is not stored in the type. It is determined at
runtime.</p></li>
<li class="fragment"><p><strong>View</strong>: a slice is <strong>never
an owned data</strong> structure.</p></li>
</ul>
</div>
</section>
<section id="slices-2" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Slices</h2>
<p>The catch with size known at compile time:</p>
<div class="columns">
<div class="column" style="width:40%;">
<pre class="rust" data-id="slice-ref-a" data-line-numbers="|1"><code>fn sum(data: [i64]) -&gt; i64 {
  let mut total = 0;

  for val in data {
    total += val;
  }

  total
}

fn main() {
  let data = vec![10, 11, 12];
  println!(&quot;{}&quot;, sum(data));
}</code></pre>
</div><div class="column fragment" style="width:60%;">
<pre class="text no-compile" data-id="slice-ref-b"
data-line-numbers="6-8"><code>error[E0277]: the size for values of type `[i64]`
              cannot be known at
              compilation time
 --&gt; src/main.rs:1:8
  |
1 | fn sum(data: [i64]) -&gt; i64 {
  |        ^^^^ doesn&#39;t have a size known
                at compile-time
  |
  = help: the trait `Sized` is not
          implemented for `[i64]`
help: function arguments must have a
      statically known size, borrowed types
      always have a known size</code></pre>
</div>
</div>
<aside class="notes">
<ul>
<li>This cannot compile because [T] cannot exist on its own because it
is never an owned data structure</li>
<li>We must always put slices behind a pointer type.</li>
</ul>
</aside>
</section>
<section id="slices-3" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Slices</h2>
<div class="columns">
<div class="column" style="width:40%;">
<pre class="rust" data-id="slice-ref-a" data-line-numbers="1"><code>fn sum(data: &amp;[i64]) -&gt; i64 {
  let mut total = 0;

  for val in data {
    total += val;
  }

  total
}

fn main() {
  let data = vec![10, 11, 12];
  println!(&quot;{}&quot;, sum(data));
}</code></pre>
</div><div class="column" style="width:60%;">
<pre class="text" data-id="slice-ref-b" data-line-numbers="6-8"><code>Compiling playground v0.0.1 (/playground)
Finished dev [unoptimized + debuginfo] target(s) in 0.89s
 Running `target/debug/playground`</code></pre>
</div>
</div>
</section>
<section id="slices---memory-layout" class="slide level2">
<h2>Slices - Memory Layout</h2>
<div class="columns">
<div class="column" style="width:50%;">
<div>
<ul>
<li class="fragment"><p><code>[T]</code> is an <strong>incomplete
type</strong>: we need to know how many <strong>of
<code>T</code>s</strong> there are.</p></li>
<li class="fragment"><p>Types with known compile-time size implement the
<code>Sized</code> trait, raw slices <strong>do not</strong>.</p></li>
<li class="fragment"><p>Slices must always be behind a reference type,
i.e.¬†<code>&amp;[T]</code> and <code>&amp;mut [T]</code> (but also
<code>Box&lt;[T]&gt;</code> etc.).</p></li>
<li class="fragment"><p>The length of the slice is always stored
together with the reference</p></li>
</ul>
</div>
</div><div class="column" style="width:50%; align-content:center;">
<div class="r-stack">
<p><img
data-src="presentations/part-1/assets/images/convert/presentations/part-1/assets/images/convert/bd8b3e21741f06f742aa44cd38af245da7f05f80.svg"
class="svgbob fade-in-then-out fragment" /></p>
<p><img
data-src="presentations/part-1/assets/images/convert/presentations/part-1/assets/images/convert/4ba8ab3f38f1d4ea14678e1ea0550e66c4ca6521.svg"
class="svgbob fade-in-then-out fragment" /></p>
</div>
</div>
</div>
</section>
<section id="creating-slices" class="slide level2">
<h2>Creating Slices</h2>
<p>One cannot create slices out of thin air, they have to be located
somewhere. Three possibilities:</p>
<div>
<ul>
<li class="fragment"><p><strong>Using a borrow:</strong></p>
<ul>
<li class="fragment">We can borrow from arrays and vectors to create a
slice of their entire contents.</li>
</ul></li>
<li class="fragment"><p><strong>Using ranges:</strong></p>
<ul>
<li class="fragment">We can use ranges to create a slice from parts of a
vector or array.</li>
</ul></li>
<li class="fragment"><p><strong>Using a literal</strong> (for immutable
slices only)<strong>:</strong></p>
<ul>
<li class="fragment">We can have memory statically available from our
compiled binary.</li>
</ul></li>
</ul>
</div>
</section>
<section id="creating-slices---borrowing" class="slide level2">
<h2>Creating Slices - Borrowing</h2>
<p>Using a borrow:</p>
<pre class="rust"><code>fn sum(data: &amp;[i32]) -&gt; i32 { /* ... */ }

fn main() {
  let v = vec![1, 2, 3, 4, 5, 6];
  let total = sum(&amp;v);

  println!(&quot;{}&quot;, total);
}</code></pre>
</section>
<section id="creating-slices---ranges" class="slide level2">
<h2>Creating Slices - Ranges</h2>
<p>Using ranges:</p>
<div class="columns">
<div class="column" style="width:50%; align-content:center;">
<pre class="rust"><code>fn sum(data: &amp;[i32]) -&gt; i32 { /* ... */ }

fn main() {
  let v = vec![0, 1, 2, 3, 4, 5, 6];
  let all = sum(&amp;v[..]);
  let except_first = sum(&amp;v[1..]);
  let except_last = sum(&amp;v[..5]);
  let except_ends = sum(&amp;v[1..5]);
}</code></pre>
</div><div class="column" style="width:50%; align-content:center;">
<ul>
<li>The range <code>start..end</code> is half-open, e.g.¬†<br>
<code>x</code> in <code>[s..e]</code> fulfills
<code>s &lt;= x &lt; e</code>.</li>
</ul>
<div>
<ul>
<li class="fragment"><p>A range is a type <a
href="https://doc.rust-lang.org/std/ops/struct.Range.html"
target="_blank"><code>std::ops::Range&lt;T&gt;</code></a>.</p>
<pre class="rust fragment"><code>use std::ops::Range;

fn main() {
  let my_range: Range&lt;u64&gt; = 0..20;

  for i in 0..10 {
    println!(&quot;{}&quot;, i);
  }
}</code></pre></li>
</ul>
</div>
</div>
</div>
</section>
<section id="creating-slices-1" class="slide level2">
<h2>Creating Slices</h2>
<p>From a literal:</p>
<pre class="rust" data-line-numbers="3-5,12|7-9,13|all"><code>fn sum(data: &amp;[i32]) -&gt; i32 { todo!(&quot;Sum all items in `data`&quot;) }

fn get_v_arr() -&gt; &amp;&#39;static [i32] {
    &amp;[0, 1, 2, 3, 4, 5, 6]
}

fn main() {
  let all = sum(get_v_arr());
}</code></pre>
<ul>
<li><p>Interestingly <code>get_v_arr</code> works, but <strong>looks
like it would only exist temporarily</strong>.</p></li>
<li><p>Literals actually exist during the entire lifetime of the
program.</p></li>
<li><p><code>&amp;'static</code> indicates: this slice exist for the
<strong>entire lifetime</strong> of the program (later more on
lifetimes).</p></li>
</ul>
</section>
<section id="more-on-strings" class="slide level2">
<h2>Strings</h2>
<p>We have already seen the <code>String</code> type being used before,
but let‚Äôs dive a little deeper</p>
<ul>
<li><p>Strings are used to represent text.</p></li>
<li><p>In Rust they are always valid UTF-8.</p></li>
<li><p>Their data is stored on the heap.</p></li>
<li><p>A <code>String</code> is similar to <code>Vec&lt;u8&gt;</code>
with extra checks to prevent creating invalid text.</p></li>
</ul>
<aside class="notes">
<ul>
<li>We store data on the heap, so we can easily have strings of variable
sizes and grow and shrink them as needed when they are modified.</li>
<li>In general we really don‚Äôt care about the exact length of the string
‚Äì&gt;</li>
</ul>
</aside>
</section>
<section id="more-on-strings" class="slide level2">
<h2>Strings</h2>
<p>Let‚Äôs take a look at some strings</p>
<pre class="rust"><code>fn main() {
  let s = String::from(&quot;Hello world üåè&quot;);

  println!(&quot;{:?}&quot;, s.split_once(&quot; &quot;));

  println!(&quot;{}&quot;, s.len());

  println!(&quot;{:?}&quot;, s.starts_with(&quot;Hello&quot;));

  println!(&quot;{}&quot;, s.to_uppercase());

  for line in s.lines() {
    println!(&quot;{}&quot;, line);
  }
}</code></pre>
</section>
<section id="string-literals" class="slide level2"
data-auto-animate="true">
<h2 data-auto-animate="true">String Literals</h2>
<p>Constructing some strings</p>
<pre class="rust" data-id="str" data-line-numbers=""><code>fn main() {
  let s1 = &quot;Hello world üåè&quot;;
  let s2 = String::from(&quot;Hello world&quot;);
}</code></pre>
<ul>
<li><code>s1</code> is a slice of type <code>&amp;str</code>: a string
slice.</li>
</ul>
</section>
<section id="string-literals-1" class="slide level2"
data-auto-animate="true">
<h2 data-auto-animate="true">String Literals</h2>
<p>Constructing some strings</p>
<pre class="rust" data-id="str" data-line-numbers="2-3"><code>fn main() {
  let s1: &amp;str = &quot;Hello world&quot;;
  let s2: String = String::from(&quot;Hello world&quot;);
}</code></pre>
</section>
<section id="the-string-slice---str" class="slide level2">
<h2>The String Slice - <code>&amp;str</code></h2>
<p>Its possible to get only a part of a string. But what is it?</p>
<div>
<ul>
<li class="fragment"><p>Not <code>[u8]</code>: not every sequence of
bytes is valid UTF-8</p></li>
<li class="fragment"><p>Not <code>[char]</code>: we could not create a
slice from a string since it is stored as UTF-8 encoded bytes <span
class="small">(one unicode character takes multiple
<code>char</code>s).</span></p></li>
</ul>
</div>
<div class="fragment">
<p><strong>It needs a new type: <code>str</code>.</strong></p>
<ul>
<li>For string slices we do not use brackets!</li>
</ul>
</div>
</section>
<section id="types-str-string-t-n-vec" class="slide level2">
<h2>Types <code>str</code>, <code>String</code>, <code>[T; N]</code>,
<code>Vec</code></h2>
<div class="columns">
<div class="column" style="width:50%; align-content: center">
<table>
<thead>
<tr class="header">
<th>Static</th>
<th>Dynamic</th>
<th>Borrowed</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>[T; N]</code></td>
<td><code>Vec&lt;T&gt;</code></td>
<td><code>&amp;[T]</code></td>
</tr>
<tr class="even">
<td>-</td>
<td><code>String</code></td>
<td><code>&amp;str</code></td>
</tr>
</tbody>
</table>
</div><div class="column" style="width:50%;">
<div>
<ul>
<li class="fragment"><p>There is no static variant of
<code>String</code>.</p></li>
<li class="fragment"><p>Only useful if we wanted strings of an exact
length.</p></li>
<li class="fragment"><p>But just like we had the static slice literals,
we can use <code>&amp;'static str</code> literals for that
instead!</p></li>
</ul>
</div>
</div>
</div>
</section>
<section id="string-or-str" class="slide level2">
<h2><code>String</code> or <code>str</code> ?</h2>
<p>When to use <code>String</code> and when <code>str</code>?</p>
<div class="columns fragment">
<div class="column">
<pre class="rust no-compile" data-line-numbers="1"><code>fn string_len1(data: &amp;String) -&gt; usize {
  data.len()
}</code></pre>
</div><div class="column fragment">
<pre class="rust does-compile" data-line-numbers="1"><code>fn string_len1(data: &amp;str) -&gt; usize {
  data.len()
}</code></pre>
</div>
</div>
<div>
<ul>
<li class="fragment"><p><span class="emph"><strong>Prefer
<code>&amp;str</code> over <code>String</code> whenever
possible.</strong></span> <br> Reason: <code>&amp;str</code> gives more
freedom to the caller Ó™ú üöÄ</p></li>
<li class="fragment"><p>To mutate a string use:
<code>&amp;mut str</code>, but you cannot change a slice‚Äôs
length.</p></li>
<li class="fragment"><p>Use <code>String</code> or
<code>&amp;mut String</code> if you need to fully mutate the
string.</p></li>
</ul>
</div>
</section>
<section id="exercise-time-6" class="slide level2">
<h2>Exercise Time (6)</h2>
<p>Approx. Time: 30-50 min</p>
<p>Do the following exercises:</p>
<ul>
<li><code>slices</code>:</li>
</ul>
<p><strong>Build/Run/Test:</strong></p>
<pre class="bash"><code>just build &lt;exercise&gt; --bin 01
just run &lt;exercise&gt; --bin 01
just test &lt;exercise&gt; --bin 01
just watch [build|run|test|watch] &lt;exercise&gt; --bin 01</code></pre>
</section></section>
<section>
<section id="recap-1" class="title-slide slide level1">
<h1>Recap 1</h1>

</section>
<section id="recap-1---references" class="slide level2">
<h2>Recap 1 - References</h2>
<ul>
<li><a href="#/shared-references">Shared References</a>
<code>&amp;T</code>: read-only, many possible.</li>
<li><a href="#/exclusive-references">Exclusive Reference</a>
<code>&amp;mut T</code>: write, only a single at any point in the
program.</li>
</ul>
</section>
<section id="recap-1---option-result" class="slide level2">
<h2>Recap 1 - <code>Option</code> &amp; <code>Result</code> &amp;
<code>?</code></h2>
<pre class="rust"><code>enum Option&lt;T&gt; {
  Some(T),
  None,
}

enum Result&lt;R, E&gt; {
  Ok(R),
  Err(E),
}</code></pre>
<ul>
<li><a href="http://localhost:3000/#/the-magic-operator/1"
target="_blank">Magic Operator</a></li>
</ul>
</section>
<section id="recap---borrow-checker" class="slide level2">
<h2>Recap - Borrow Checker</h2>
<ul>
<li><a href="#/borrow-checkers-scope">The borrow Checkers
Scope</a>.</li>
</ul>
</section>
<section id="quiz---does-that-compile" class="slide level2">
<h2>Quiz - Does that Compile?</h2>
<div class="columns">
<div class="column" style="width:55%;">
<pre class="rust" data-line-numbers=""><code>#[derive(Debug)]
enum Color {None, Blue}
struct Egg { color: Color }

fn colorize(egg: &amp;mut Egg) -&gt; &amp;Color {
  egg.color = Color::Blue;
  return &amp;egg.color
}

fn main() {
  let mut egg = Egg {color: Color::None};
  let color: &amp;Color;
  {
    let egg_ref = &amp;mut egg;
    color = colorize(egg_ref)
  }
  println!(&quot;color: {color:?}&quot;)
}</code></pre>
</div><div class="column" style="width:45%;">
<p><strong>Question:</strong> Does that compile?</p>
<p><span class="fragment"><strong>Answer</strong>: Yes, <code>get</code>
takes a shared reference of a field in a <code>&amp;mut Egg</code> which
works because we do not access <code>egg_ref</code> after
L15.</span></p>
</div>
</div>
</section>
<section id="quiz---addendum" class="slide level2">
<h2>Quiz - Addendum</h2>
<p>The <code>colorize</code> method is basically a method on
<code>Egg</code> which takes a <strong>exclusive reference</strong>
<code>&amp;mut self</code> only for the duration of that function.</p>
<pre class="rust" data-line-numbers=""><code>#[derive(Debug)]
enum Color {None, Blue}
struct Egg { color: Color }

impl Egg {
  fn colorize(&amp;mut self) -&gt; &amp;Color {
    self.color = Color::Blue;
    return &amp;self.color
  }
}

fn main() {
  let mut egg = Egg {color: Color::None};
  let color: &amp;Color;
  {
    color = egg.colorize()
  }
  println!(&quot;color: {color:?}&quot;)
}</code></pre>
<!-- markdownlint-disable-file MD034 MD033 MD001 MD024 MD026-->
</section></section>
<section>
<section id="smart-pointers" class="title-slide slide level1">
<h1>Smart Pointers</h1>

</section>
<section id="put-it-in-a-box" class="slide level2">
<h2>Put it in a <code>Box</code></h2>
<p><a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"
target="_blank"><code>Box&lt;T&gt;</code></a> will allocate a type
<code>T</code> on the heap and wrap the pointer underneath:</p>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust"><code>fn main() {
  // Put an integer on the heap
  let boxed_int: Box&lt;i64&gt; = Box::new(10);
}</code></pre>
</div><div class="column" style="width:50%;">
<div class="center-content p-no-margin">
<figure id="fig:smart-pointer-box">
<img
data-src="presentations/part-1/assets/images/convert/presentations/part-1/assets/images/convert/cea9d7a8875dd36c56d518f9297049188f7e90f3.svg"
class="svgbob" alt="Smart Pointer to the Heap" />
<figcaption aria-hidden="true">Smart Pointer to the Heap</figcaption>
</figure>
</div>
</div>
</div>
<ul>
<li>üß∞ <strong>Boxing</strong>: Store a type <code>T</code> on the
heap.</li>
</ul>
<div>
<ul>
<li class="fragment">üëë <code>Box</code> <strong>uniquely owns</strong>
that value. Nobody else does.</li>
<li class="fragment">üß∫ A <code>Box</code> variable will deallocate the
memory when out-of-scope.</li>
<li class="fragment">üöÇ Move semantics apply to a <code>Box</code>. Even
if the type inside the box is <code>Copy</code>.</li>
</ul>
</div>
</section>
<section id="boxing" class="slide level2">
<h2>Boxing</h2>
<p>Reasons to box a type <code>T</code> on the heap:</p>
<div>
<ul>
<li class="fragment"><p>When something is too large to move around
‚è±Ô∏è.</p></li>
<li class="fragment"><p>Need something dynamically sized
(<code>dyn Trait</code> later).</p></li>
<li class="fragment"><p>For writing recursive data structures:</p>
<pre class="rust fragment"><code>struct Node {
  data: Vec&lt;u8&gt;,
  parent: Box&lt;Node&gt;,
}</code></pre></li>
</ul>
</div>
<aside class="notes">
<ul>
<li><p>Allowing arbitrarily large values on the stack would quickly let
our function calls exhaust the stack limit</p>
<ul>
<li>Especially if a move actually would involve memcopying the bits to
another location in memory that would take way too long</li>
</ul></li>
<li><p>Of course the main reason that a vector uses the heap is to be
able to be sized dynamically, but even so, a vector can be large,
whereas an array will generally always have a limited size</p></li>
</ul>
</aside>
</section>
<section id="exercise-time-7" class="slide level2">
<h2>Exercise Time (7)</h2>
<p>Approx. Time: 40-50 min.</p>
<p>Do the following exercises:</p>
<ul>
<li>exercise: <code>boxed-data</code>: all</li>
</ul>
<p><strong>Build/Run/Test:</strong></p>
<pre class="bash"><code>just build &lt;exercise&gt; --bin 01
just run &lt;exercise&gt; --bin 01
just test &lt;exercise&gt; --bin 01
just watch [build|run|test|watch] &lt;exercise&gt; --bin 01</code></pre>
<!-- markdownlint-disable-file MD034 MD033 MD001 MD024 MD026-->
</section></section>
<section>
<section id="traits-and-generics" class="title-slide slide level1">
<h1>Traits and Generics</h1>

</section>
<section id="the-problem" class="slide level2">
<h2>The Problem</h2>
<pre class="rust"><code>fn add_u32(l: u32, r: u32) -&gt; u32 { /*...*/}

fn add_i32(l: i32, r: i32) -&gt; i32 { /*...*/ }

fn add_f32(l: f32, r: f32) -&gt; f32 { /*...*/ }</code></pre>
<p>No-one likes repeating themselves. <span class="fragment"><strong>We
need generic code!</strong></span></p>
<aside class="notes">
<p>Let‚Äôs have a look at this Rust module. We‚Äôd like to provide
functionality for finding the maximum of two numbers, for several
distinct types. One way to go about it, is to define many similar
functions that perform the operation. But there‚Äôs a number of problems
with that:</p>
<ul>
<li>What happens if we want to compare other types?</li>
<li>What happens if we want to compare separate types?</li>
</ul>
</aside>
</section>
<section id="generic-code" class="slide level2">
<h2>Generic code</h2>
<p>An example</p>
<pre class="rust"><code>fn add&lt;T&gt;(a: T, b: T) -&gt; T { /*...*/}</code></pre>
<p>Or, in plain English:</p>
<div>
<ul>
<li class="fragment"><code>&lt;T&gt;</code> : <em>‚Äúlet <code>T</code> be
a type‚Äù</em>.</li>
<li class="fragment"><code>a: T</code> : <em>‚Äúlet <code>a</code> be of
type <code>T</code>‚Äù</em>.</li>
<li class="fragment"><code>-&gt; T</code> : <em>‚Äúlet <code>T</code> be
the return type of this function‚Äù</em>.</li>
</ul>
</div>
<div class="fragment">
<p>Some open points:</p>
<ul>
<li>What can we do with a <code>T</code>?</li>
<li>What should the body be?</li>
</ul>
</div>
</section>
<section id="bounds-on-generic-code" class="slide level2">
<h2>Bounds on Generic Code</h2>
<p>We need to provide information to the compiler:</p>
<div>
<ul>
<li class="fragment">Tell Rust what <code>T</code> can do.</li>
<li class="fragment">Tell Rust which types for <code>T</code> are
accepted.</li>
<li class="fragment">Tell Rust how <code>T</code> implements
functionality.</li>
</ul>
</div>
</section>
<section id="the-trait-keyword" class="slide level2">
<h2>The <code>trait</code> Keyword</h2>
<p>Describe what the type can do <strong>but not specifying what data it
has</strong>:</p>
<pre class="rust"><code>trait Add {
    fn add(&amp;self, other: &amp;Self) -&gt; Self;
}</code></pre>
<p>This is similar in other languages:</p>
<div class="columns">
<div class="column fragment">
<p>Python (not as strict üôÅ):</p>
<pre class="python"><code>from abc import ABC, abstractmethod
class Add(ABC):
    @abstractmethod
    def add(self, other: Self):
        pass</code></pre>
</div><div class="column fragment">
<p>Go:</p>
<pre class="go"><code>type Add interface {
    func add(other Add)
}</code></pre>
</div>
</div>
<p>::: notes Traits are <strong>not</strong> types! :::</p>
</section>
<section id="implementing-a-trait" class="slide level2">
<h2>Implementing a <code>trait</code></h2>
<p>Describe how the type does it</p>
<pre class="rust" data-line-numbers="2-4"><code>impl Add for u32 {
    fn add(&amp;self, other: &amp;Self) -&gt; Self {
      *self + *other
    }
}</code></pre>
</section>
<section id="using-a-trait" class="slide level2">
<h2>Using a <code>trait</code></h2>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" data-line-numbers="1-2|5-6|7-8|9-10"><code>// Import the trait
use my_mod::Add

fn main() {
  let a: u32 = 6;
  let b: u32 = 8;
  // Call trait method
  let result = a.add(&amp;b);
  // Explicit call
  let result = Add::add(&amp;a, &amp;b);
}</code></pre>
</div><div class="column" style="align-content:center; width:50%">
<ul>
<li>Trait needs to be in scope.</li>
<li>Call just like a method.</li>
<li>Or by using the explicit associated function syntax.</li>
</ul>
</div>
</div>
</section>
<section id="trait-bounds" class="slide level2">
<h2>Trait Bounds</h2>
<div class="columns">
<div class="column" style="width:55%;">
<pre class="rust" data-line-numbers="1-2|5-7|13-14"><code>fn add_values&lt;T: Add&gt;(this: &amp;T,
                      other: &amp;T) -&gt; T {
  this.add(other)
}
// or, equivalently
fn add_values&lt;T&gt;(this: &amp;T,
                 other: &amp;T) -&gt; T
  where T: Add
{
  this.add(other)
}
// or shorthand with `impl Trait`
fn add_values(this: &amp;impl Add,
              other: &amp;impl Add) -&gt; impl Add
{
  this.add(other)
}</code></pre>
</div><div class="column" style="width:45%; align-content:center;">
<ul>
<li><p>We‚Äôve got a <em>useful</em> generic function!</p></li>
<li><p>English: <em>‚ÄúFor all types <code>T</code> that implement the
<code>Add</code> trait, we define‚Ä¶‚Äù</em></p></li>
</ul>
</div>
</div>
</section>
<section id="limitations-of-add" class="slide level2">
<h2>Limitations of <code>Add</code></h2>
<p>What happens if‚Ä¶</p>
<ul>
<li>We want to add two values of different types?</li>
<li>Addition yields a different type?</li>
</ul>
</section>
<section id="making-add-generic" class="slide level2">
<h2>Making <code>Add</code> Generic</h2>
<p>Generalize on the input type <code>O</code>:</p>
<pre class="rust" data-line-numbers="1-3|5-9"><code>trait Add&lt;O&gt; {
    fn add(&amp;self, other: &amp;O) -&gt; Self;
}

impl Add&lt;u16&gt; for u32 {
    fn add(&amp;self, other: &amp;u16) -&gt; Self {
      *self + (*other as u32)
    }
}</code></pre>
<p>We can now add a <code>u16</code> to a <code>u32</code>.</p>
</section>
<section id="defining-output-of-add" class="slide level2">
<h2>Defining Output of <code>Add</code></h2>
<ul>
<li>Addition of two given types always yields one <strong>specific type
of output</strong>.</li>
<li>Add <em>associated type</em> for addition output.</li>
</ul>
<div class="columns">
<div class="column fragment" style="width:50%;">
<p><strong>Declaration</strong></p>
<pre class="rust" data-line-numbers="2|3"><code>trait Add&lt;O&gt; {
  type Out;
  fn add(&amp;self, other: &amp;O) -&gt; Self::Out;
}</code></pre>
</div><div class="column fragment" style="width:50%;">
<p><strong>Implementation</strong></p>
<pre class="rust" data-line-numbers="1,9|4-6"><code>impl Add&lt;u16&gt; for u32 {
  type Out = u64;

  fn add(&amp;self, other: &amp;u16) -&gt; Self::Out) {
    *self as u64 + (*other as u64)
  }
}</code></pre>
</div>
</div>
</section>
<section id="trait-stdopsadd" class="slide level2">
<h2>Trait <code>std::ops::Add</code></h2>
<p>The way <code>std</code> does it</p>
<pre class="rust" data-line-numbers="1|2-4"><code>pub trait Add&lt;Rhs = Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}</code></pre>
<ul>
<li>Default type of <code>Self</code> for <code>Rhs</code></li>
</ul>
</section>
<section id="implementation-of-stdopsadd" class="slide level2">
<h2>Implementation of <code>std::ops::Add</code></h2>
<pre class="rust"><code>use std::ops::Add;
pub struct BigNumber(u64);

impl Add for BigNumber {
  type Output = Self;

  fn add(self, rhs: Self) -&gt; Self::Output {
      BigNumber(self.0 + rhs.0)
  }
}

fn main() {
  // Call `Add::add`
  let res = BigNumber(1).add(BigNumber(2));
}</code></pre>
<p><strong>Quiz:</strong> What‚Äôs the type of <code>res</code>? <span
class="fragment">Ó™ú <code>BigNumber(u64)</code></span></p>
</section>
<section id="implementation-stdopsadd-2" class="slide level2">
<h2>Implementation <code>std::ops::Add</code> (2)</h2>
<pre class="rust"><code>pub struct BigNumber(u64);

impl std::ops::Add&lt;u32&gt; for BigNumber {
  type Output = u128;

  fn add(self, rhs: u32) -&gt; Self::Output {
      (self.0 as u128) + (rhs as u128)
  }
}

fn main() {
  let res = BigNumber(1) + 3u32;
}</code></pre>
<p><strong>Quiz:</strong> What‚Äôs the type of <code>res</code>? <span
class="fragment">Ó™ú <code>u128</code></span></p>
</section>
<section id="type-parameter-vs.-associated-type" class="slide level2">
<h2>Type Parameter vs.¬†Associated Type</h2>
<div class="columns">
<div class="column" style="width:50%;">
<h4 id="use-type-parameter">Use Type Parameter</h4>
<p><em>if trait can be implemented for <strong>many combinations of
types</strong></em></p>
<pre class="rust"><code>impl Add&lt;u32&gt; for u32 {/* */}
impl Add&lt;i64&gt; for u32 {/* */}</code></pre>
</div><div class="column" style="width:50%;">
<h4 id="use-associated-type">Use Associated Type</h4>
<p>to define a type <strong>internal</strong> to the trait, which the
<strong>implementer chooses</strong>:</p>
<pre class="rust"><code>impl Add&lt;u32&gt; for u32 {
  // Addition of two u32&#39;s is always u32
  type Out = u32;
}</code></pre>
</div>
</div>
<aside class="notes">
<ul>
<li>The implementer chooses the associated type <code>Out</code> in
<code>Add</code>.</li>
<li>The caller which writes a generic function using this
<code>Add</code> trait does not need to specify <code>Out</code> its
defined at the implementations place.</li>
</ul>
</aside>
</section>
<section id="example---associated-types" class="slide level2">
<h2>Example - Associated Types</h2>
<pre class="rust"><code>trait Distance {
    type Scalar;

    fn distance(&amp;self, a: &amp;Self::Scalar, b: &amp;Self::Scalar) -&gt; bool;
    fn first(&amp;self) -&gt; &amp;Self::Scalar;
    fn last(&amp;self) -&gt; &amp;Self::Scalar;
}

// Implement Distance for some types here ....
impl Distance for ...

// The caller specifying a bound does not need to
// specify the `Scalar`.
fn distance&lt;T: Distance&gt;(container: &amp;T) -&gt; bool {
    container.distance(container.first(), container.last())
}</code></pre>
<p><a
href="https://doc.rust-lang.org/rust-by-example/generics/assoc_items/the_problem.html"
target="_blank">If we would have chosen
<code>trait Distance&lt;Scalar&gt;</code></a> instead, the type
<code>Scalar</code> need to be provided everywhere its used.</p>
</section>
<section id="derive-a-trait" class="slide level2">
<h2>Derive a Trait</h2>
<pre class="rust"><code>#[derive(Clone, Debug)]
struct Dolly {
  num_legs: u32,
}

fn main() {
  let dolly = Dolly { num_legs: 4 };
  let second_dolly = dolly.clone();

  println!(&quot;Dolly: {:?}&quot;, second_dolly)
}</code></pre>
<div>
<ul>
<li class="fragment">Some traits are trivial to implement.</li>
<li class="fragment">Use <code>#[derive(...)]</code> to quickly
implement a trait.</li>
<li class="fragment">For <code>Clone</code>: derived <code>impl</code>
calls <code>clone</code> on each field.</li>
<li class="fragment"><code>Debug</code>: provide a debug implementation
for string formatting.</li>
</ul>
</div>
</section>
<section id="culprits-with-deriveclone" class="slide level2">
<h2>Culprits with <code>#[derive(Clone)]</code></h2>
<pre class="rust"><code>struct NonClone{}

#[derive(Clone)]
struct A&lt;T&gt; { a: Arc&lt;T&gt; }

fn main() {
  let a = A { a: Arc::new(NonClone{})};
}</code></pre>
<p><strong>Question:</strong> Does that compile?</p>
<div class="fragment">
<p><strong>Answer: No but it should.</strong></p>
<div>
<ul>
<li class="fragment"><code>#[derive(Clone)]</code> de-sugars into
<code>impl&lt;T&gt; Clone for A&lt;T&gt; where T: Clone</code> which
adds a wrong and unnecessary bound <code>T: Clone</code> (maybe that
changes in the future).</li>
</ul>
</div>
</div>
</section>
<section id="orphan-rule" class="slide level2">
<h2>Orphan Rule</h2>
<p><em>Coherence: There must be <strong>at most one</strong>
implementation of a trait for any given type</em></p>
<div class="fragment">
<h4 id="rule">Rule</h4>
<p>Trait can be implemented for a type <strong>iff</strong>:</p>
<div>
<ul>
<li class="fragment">Either <strong>your crate</strong> (library)
defines the trait</li>
<li class="fragment">or <strong>your crate</strong> (library) defines
the type</li>
<li class="fragment">or both.</li>
</ul>
</div>
<div>
<p><br></p>
<ul>
<li class="fragment"><strong>You cannot implement a foreign trait for a
foreign type.</strong></li>
</ul>
</div>
</div>
</section>
<section id="compiling-generic-functions" class="slide level2">
<h2>Compiling Generic Functions</h2>
<pre class="rust"><code>impl Add for i32 {/* ... */}
impl Add for f32 {/* ... */}

fn add_values&lt;T: Add&gt;(a: &amp;T, b: &amp;T) -&gt; T
{
  a.add(b)
}

fn main() {
  let sum_one = add_values(&amp;6, &amp;8);
  let sum_two = add_values(&amp;6.5, &amp;7.5);
}</code></pre>
<p>Code is <strong>monomorphized</strong>:</p>
<div>
<ul>
<li class="fragment">Two versions of <code>add_values</code> end up in
binary.</li>
<li class="fragment">Optimized separately and very fast to run (static
dispatch).</li>
<li class="fragment">Slow to compile and larger binary.</li>
</ul>
</div>
</section>
<section id="exercise-time-8" class="slide level2">
<h2>Exercise Time (8)</h2>
<p>Approx. Time: 40-50 min.</p>
<p>Do the following exercises:</p>
<ul>
<li><code>generics</code>: all</li>
</ul>
<p><strong>Build/Run/Test:</strong></p>
<pre class="bash"><code>just build &lt;exercise&gt; --bin 01
just run &lt;exercise&gt; --bin 01
just test &lt;exercise&gt; --bin 01
just watch [build|run|test|watch] &lt;exercise&gt; --bin 01</code></pre>
</section></section>
<section>
<section id="common-traits-from-std" class="title-slide slide level1">
<h1>Common Traits from <code>std</code></h1>

</section>
<section id="operator-overloading" class="slide level2">
<h2>Operator Overloading</h2>
<h4 id="stdopsaddt-et-al."><code>std::ops::Add&lt;T&gt;</code> et
al.</h4>
<ul>
<li>Shared behavior</li>
</ul>
<pre class="rust" data-line-numbers="12"><code>use std::ops::Add;
pub struct BigNumber(u64);

impl Add for BigNumber {
  type Output = Self;
  fn add(self, rhs: Self) -&gt; Self::Output {
      BigNumber(self.0 + rhs.0)
  }
}
fn main() {
  // Now we can use `+` to add `BigNumber`s!
  let res: BigNumber = BigNumber(1) + BigNumber(2);
}</code></pre>
<ul>
<li>Others: <code>Mul</code>, <code>Div</code>, <code>Sub</code>,
..</li>
</ul>
</section>
<section id="markers" class="slide level2">
<h2>Markers</h2>
<h4 id="stdmarkersized"><code>std::marker::Sized</code></h4>
<ul>
<li>Marker traits</li>
</ul>
<pre class="rust"><code>/// Types with a constant size known at compile time.
/// [...]
pub trait Sized { }</code></pre>
<div>
<ul>
<li class="fragment"><em><code>u32</code> is
<code>Sized</code></em></li>
<li class="fragment"><em>Slice <code>[T]</code>, <code>str</code> is
<strong>not</strong> <code>Sized</code></em></li>
<li class="fragment"><em>Slice reference <code>&amp;[T]</code>,
<code>&amp;str</code> is <code>Sized</code></em></li>
</ul>
</div>
<p>Others:</p>
<ul>
<li><code>Sync</code>: Types of which references can be shared between
threads.</li>
<li><code>Send</code>: Types that can be transferred across thread
boundaries.</li>
</ul>
</section>
<section id="default-values" class="slide level2">
<h2>Default Values</h2>
<h4 id="stddefaultdefault"><code>std::default::Default</code></h4>
<pre class="rust" data-line-numbers="5|10-17"><code>pub trait Default: Sized {
    fn default() -&gt; Self;
}

#[derive(Default)] // Derive the trait
struct MyCounter {
  count: u32,
}

// Or, implement it (if you really need to)
impl Default for MyCounter {
  fn default() -&gt; Self {
    MyCounter { count: 1 }
  }
}</code></pre>
</section>
<section id="duplication" class="slide level2">
<h2>Duplication</h2>
<h4 id="stdcloneclone-stdmarkercopy"><code>std::clone::Clone</code>
&amp; <code>std::marker::Copy</code></h4>
<pre class="rust" data-line-numbers="9|4-6"><code>pub trait Clone: Sized {
    fn clone(&amp;self) -&gt; Self;

    fn clone_from(&amp;mut self, source: &amp;Self) {
      *self = source.clone()
    }
}

pub trait Copy: Clone { } // That&#39;s it!</code></pre>
<div>
<ul>
<li class="fragment">Both <code>Copy</code> and <code>Clone</code> can
be <code>#[derive]</code>d.</li>
<li class="fragment"><code>Copy</code> is a marker trait.</li>
<li class="fragment"><code>trait A: B</code> == <em>‚ÄúImplementor of
<code>A</code> must also implement <code>B</code>‚Äù</em></li>
<li class="fragment"><code>clone_from</code> has default implementation,
can be overridden.</li>
</ul>
</div>
</section>
<section id="conversions" class="slide level2">
<h2>Conversions</h2>
<h4 id="intot-fromt"><code>Into&lt;T&gt;</code> &amp;
<code>From&lt;T&gt;</code></h4>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" data-line-numbers="1-3|5-7|9-15"><code>pub trait From&lt;T&gt;: Sized {
    fn from(value: T) -&gt; Self;
}

pub trait Into&lt;T&gt;: Sized {
    fn into(self) -&gt; T;
}

impl &lt;T, U&gt; Into&lt;U&gt; for T
  where U: From&lt;T&gt;
{
    fn into(self) -&gt; U {
      U::from(self)
    }
}</code></pre>
</div><div class="column" style="width:50%; align-content:center;">
<div>
<ul>
<li class="fragment">Blanket implementation.</li>
<li class="fragment"><em>Prefer <code>From</code> over <code>Into</code>
if orphan rule allows to</em>.</li>
</ul>
</div>
</div>
</div>
</section>
<section id="reference-conversion" class="slide level2">
<h2>Reference Conversion</h2>
<h4 id="asreft-asmutt"><code>AsRef&lt;T&gt;</code> &amp;
<code>AsMut&lt;T&gt;</code></h4>
<pre class="rust"><code>pub trait AsRef&lt;T: ?Sized&gt;
{
    fn as_ref(&amp;self) -&gt; &amp;T;
}

pub trait AsMut&lt;T: ?Sized&gt;
{
    fn as_mut(&amp;mut self) -&gt; &amp;mut T;
}</code></pre>
<ul>
<li>Provide flexibility to API users.</li>
<li><code>T</code> need not be <code>Sized</code>, e.g.¬†slices
<code>[T]</code> can implement <code>AsRef&lt;T&gt;</code>,
<code>AsMut&lt;T&gt;</code></li>
</ul>
</section>
<section id="reference-conversion-2" class="slide level2">
<h2>Reference Conversion (2)</h2>
<h4 id="asreft-asmutt-1"><code>AsRef&lt;T&gt;</code> &amp;
<code>AsMut&lt;T&gt;</code></h4>
<pre class="rust" data-line-numbers="1-2|9-10|12-13"><code>fn move_into_and_print&lt;T: AsRef&lt;[u8]&gt;&gt;(slice: T) {
  let bytes: &amp;[u8] = slice.as_ref();
  for byte in bytes {
    print!(&quot;{:02X}&quot;, byte);
  }
}

fn main() {
  let owned_bytes: Vec&lt;u8&gt; = vec![0xDE, 0xAD, 0xBE, 0xEF];
  move_into_and_print(owned_bytes);

  let byte_slice: [u8; 4] = [0xFE, 0xED, 0xC0, 0xDE];
  move_into_and_print(byte_slice);
}</code></pre>
<p><em>Have user of <code>move_into_and_print</code> choose between
stack local <code>[u8; N]</code> and heap-allocated
<code>Vec&lt;u8&gt;</code></em></p>
</section>
<section id="destruction-stdopsdrop" class="slide level2">
<h2>Destruction: <code>std::ops::Drop</code></h2>
<pre class="rust"><code>pub trait Drop {
    fn drop(&amp;mut self);
}</code></pre>
<ul>
<li>Called when owner goes out of scope.</li>
</ul>
</section>
<section id="destructionstdopsdrop" class="slide level2">
<h2>Destruction:<code>std::ops::Drop</code></h2>
<div class="columns">
<div class="column" style="width:55%;">
<pre class="rust" data-line-numbers="1-2|4-8|9-13|17"><code>struct Inner;
struct Outer { inner: Inner }

impl Drop for Inner {
  fn drop(&amp;mut self) {
    println!(&quot;Dropped inner&quot;);
  }
}
impl Drop for Outer {
  fn drop(&amp;mut self) {
    println!(&quot;Dropped outer&quot;);
  }
}

fn main() {
  // Explicit drop
  std::mem::drop(Outer { inner: Inner });
}</code></pre>
</div><div class="column" style="width:45%;">
<p><strong>Output</strong>:</p>
<pre class="text"><code>Dropped outer
Dropped inner</code></pre>
<ul>
<li>Destructor runs <em>before</em> members are removed from stack.</li>
<li>Signature <code>&amp;mut</code> prevents explicitly dropping
<code>self</code> or its fields in destructor.</li>
<li>Compiler inserts <code>std::mem::drop</code> call at end of
scope</li>
</ul>
<pre class="rust"><code>// Implementation of `std::mem::drop`
fn drop&lt;T&gt;(_x: T) {}</code></pre>
<p><strong>Question:</strong> Why does <code>std::mem::drop</code>
work?</p>
</div>
</div>
<aside class="notes">
<ul>
<li>You can only borrow once a <code>&amp;mut</code>.</li>
<li>Drop works, because it takes ownership by <code>T</code>, which
means the borrowing rules ensure drop can only be called once. Its a
sink function.</li>
<li>TODO: Whats the rules how drop gets sequenced, same as C++
(AFAIK)</li>
</ul>
</aside>
</section>
<section id="more-std-traits" class="slide level2">
<h2>More Std-Traits</h2>
<p>There is more:</p>
<ul>
<li><a
href="https://google.github.io/comprehensive-rust/std-traits/comparisons.html"
target="_blank">Comparison</a> <code>PartialEq</code> and
<code>Eq</code> etc.</li>
<li><a
href="https://google.github.io/comprehensive-rust/std-traits/read-and-write.html"
target="_blank"><code>Read</code> and <code>BufRead</code></a> for
abstraction over <code>u8</code> sources.</li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"
target="_blank"><code>Display</code></a> and <a
href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"
target="_blank"><code>Debug</code></a> to format types.</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html"
target="_blank">Iterator</a> to provide an iterator for your type.</li>
</ul>
</section>
<section id="std-traits-and-the-orphan-rule" class="slide level2">
<h2>Std-Traits and the Orphan Rule</h2>
<p>When you <strong>provide a type</strong>, <strong>always</strong>
implement (or derive) the basic traits from the standard if they are
appropriate, e.g.¬†(<code>&gt;</code> implies priority)</p>
<div>
<ul>
<li class="fragment"><code>Default</code> : Initialize the type with
default values.</li>
<li class="fragment"><code>Debug</code> &gt; <code>Display</code> :
Format trait for debug specifier <code>{:?}</code> or non-debug with
with <code>{}</code>.</li>
<li class="fragment"><code>Clone</code>: Cloning the type or bitwise
copy.</li>
<li class="fragment"><code>PartialEq</code> &gt; <code>PartialOrd</code>
(and maybe <code>Eq</code> &gt; <code>Ord</code>).</li>
<li class="fragment"><code>Hash</code>: To store the type in
<code>HashMap</code> etc.</li>
<li class="fragment"><code>Copy</code>: <strong>Only implement
<em>marker-trait</em> <code>Copy</code> if you really need
to.</strong></li>
</ul>
</div>
<div>
<p>Other traits for later:</p>
<ul>
<li class="fragment"><code>Send</code> : <em>Auto</em> trait: A value
<code>T</code> can safely be send across thread boundary.</li>
<li class="fragment"><code>Sync</code> : <em>Auto</em> trait: A value
<code>T</code> can safely be shared between threads.</li>
<li class="fragment"><code>Sized</code> : <em>Marker</em> trait to
denote that type <code>T</code> is known at compile time</li>
</ul>
</div>
<aside class="notes">
<p>Marker traits do not need an implementation. Auto traits are auto
implemented if the types fulfills the conditions. Copy trait changes the
semantics of moving and removing <code>Copy</code> on an exposed type is
a backward-incompatible change.</p>
</aside>
</section>
<section id="exercise-time-9" class="slide level2">
<h2>Exercise Time (9)</h2>
<p>Approx. Time: 40-50 min.</p>
<p>Do the following exercises:</p>
<ul>
<li><code>traits</code></li>
<li><code>std-traits</code></li>
<li><code>blanket-implementation</code></li>
<li><code>drop-with-errors</code></li>
<li><code>extension-traits</code>: a very good one (moderate to
hard)!</li>
<li><code>local-storage-vec</code>: ‚ö†Ô∏è Hardcore exercise (spare for
later)</li>
</ul>
<p><strong>Build/Run/Test:</strong></p>
<pre class="bash"><code>just build &lt;exercise&gt; --bin 01
just run &lt;exercise&gt; --bin 01
just test &lt;exercise&gt; --bin 01
just watch [build|run|test|watch] &lt;exercise&gt; --bin 01</code></pre>
</section></section>
<section>
<section id="lifetime-annotations" class="title-slide slide level1">
<h1>Lifetime Annotations</h1>

</section>
<section id="what-lifetime" class="slide level2">
<h2>What Lifetime?</h2>
<div>
<ul>
<li class="fragment"><p>References refer to variables (stack-allocated
memory).</p></li>
<li class="fragment"><p>A variable has a lifetime:</p>
<ul>
<li class="fragment">Starts at declaration.</li>
<li class="fragment">Ends at <code>drop</code>.</li>
</ul></li>
<li class="fragment"><p>The barrow checker prevents dangling references
(pointing to deallocated/invalid memory üí£).</p></li>
</ul>
</div>
</section>
<section id="example---lifetime-scopes" class="slide level2">
<h2>Example - Lifetime Scopes</h2>
<pre class="rust" data-line-numbers=""><code>fn main() {
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!(&quot;r: {r}&quot;);
}</code></pre>
<p><strong>Question</strong>: Will this compile?</p>
</section>
<section id="example---lifetime-scopes-2" class="slide level2">
<h2>Example - Lifetime Scopes (2)</h2>
<p>Variable <code>r</code> lives for lifetime <code>'a</code> and
<code>x</code> for <code>'b</code>.</p>
<pre class="rust no-compile" data-line-numbers="9"><code>fn main() {
    let r;                // ---------+- &#39;a
                          //          |
    {                     //          |
        let x = 5;        // -+-- &#39;b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!(&quot;r: {r}&quot;);   //          |
}                         // ---------+</code></pre>
<p><strong>Answer</strong>: No, <code>r</code> points to <code>x</code>
which is dropped in L6.</p>
</section>
<section id="example---lifetime-in-function-1" class="slide level2">
<h2>Example - Lifetime in Function (1)</h2>
<p><strong>Question</strong>: Will this compile?</p>
<pre class="rust"><code>/// Return reference to longest of `a` or `b`.
fn longer(a: &amp;str, b: &amp;str) -&gt; &amp;str {
    if a.len() &gt; b.len() {
        a
    } else {
        b
    }
}</code></pre>
</section>
<section id="example---lifetime-in-function-2" class="slide level2">
<h2>Example - Lifetime in Function (2)</h2>
<p><strong>Answer</strong>: No.¬†<code>rustc</code> needs to know more
about <code>a</code> and <code>b</code>.</p>
<div class="columns">
<div class="column" style="width:45%;">
<pre class="rust" data-line-numbers="3"><code>/// Return reference to longest
/// of `a` and `b`.
fn longer(a: &amp;str, b: &amp;str) -&gt; &amp;str {
  if a.len() &gt; b.len() {
      a
  } else {
      b
  }
}</code></pre>
</div><div class="column" style="width:55%;">
<pre class="text no-compile" data-line-numbers="4,12"
style="font-size:14pt"><code>error[E0106]: missing lifetime specifier
 --&gt; src/lib.rs:2:32
  |
2 | fn longer(a: &amp;str, b: &amp;str) -&gt; &amp;str {
  |              ----     ----     ^
  | expected named lifetime parameter
  |
  = help: this function&#39;s return type contains
    a borrowed value, but the signature does
    not say whether it is borrowed from `a` or `b`
help: consider introducing a named lifetime parameter
2 | fn longer&lt;&#39;a&gt;(a: &amp;&#39;a str, b: &amp;&#39;a str) -&gt; &amp;&#39;a str {
  |          ++++     ++          ++          ++

For more information about this error,
try `rustc --explain E0106`.</code></pre>
</div>
</div>
</section>
<section id="lifetime-annotations-1" class="slide level2">
<h2>Lifetime Annotations</h2>
<p><strong>Solution</strong>: Provide a <strong>constraint</strong> with
a lifetime parameter <code>'l</code>:</p>
<pre class="rust does-compile" data-line-numbers="1"><code>fn longer&lt;&#39;l&gt;(a: &amp;&#39;l str, b: &amp;&#39;l str) -&gt; &amp;&#39;l str {
    if a.len() &gt; b.len() {
        a
    } else {
        b
    }
}</code></pre>
<div class="columns">
<div class="column" style="width:50%;">
<p><strong>English:</strong></p>
<div>
<ul>
<li class="fragment">Given a lifetime called <code>'l</code>,</li>
<li class="fragment"><code>longer</code> takes two references
<code>a</code> and <code>b</code></li>
<li class="fragment">that live for
<strong><code>&gt;= 'l</code></strong></li>
<li class="fragment">and returns a reference that lives for
<code>'l</code>.</li>
</ul>
</div>
</div><div class="column" style="width:50%;">
<div class="fragment">
<p><strong>‚ùó<span class="emph">Annotations do NOT change the lifetime
of variables. Their scopes do.</span></strong><br> Annotations are
<strong>constraints</strong> to provide information to the borrow
checker.</p>
</div>
</div>
</div>
</section>
<section id="validating-boundaries" class="slide level2">
<h2>Validating Boundaries</h2>
<ul>
<li>Lifetime validation is done within function boundaries (and scopes
e.g. <code>{...}</code>).</li>
<li>No information of calling context is used.</li>
</ul>
<p><strong>Question:</strong> Why no calling context?</p>
<p><span class="fragment"><strong>Answer:</strong> Because its only
important to know the lifetime relation between <strong>input &amp;
output</strong> - the constraint.</span></p>
</section>
<section id="example---validating-boundaries" class="slide level2">
<h2>Example - Validating Boundaries</h2>
<pre class="rust" contenteditable="true"><code>fn main() {
  let x = 3;                       // ------------+- &#39;a
  {                                //                 |
    let y = 10;                    // ------+--- &#39;b   |
    let r: &amp;i64 = longest(&amp;x, &amp;y); // --+- &#39;c     |   |  &#39;l := min(&#39;a,&#39;b) =&gt; &#39;l := &#39;b
    println!(&quot;longest: {r}&quot;)       //   |         |   |
  }                                // --+---------+   |
}                                  // ----------------+</code></pre>
<p>Borrow checker checks if <code>r</code>‚Äôs lifetime fulfills
<code>&lt;= 'b</code> Ó™ú <code>'c &lt;= 'b</code> Ó™ú ‚úÖ.</p>
</section>
<section id="lifetime-annotations-in-types" class="slide level2">
<h2>Lifetime Annotations in Types</h2>
<p>If references are used in <code>struct</code>s, it needs a life-time
annotation:</p>
<pre class="rust"><code>/// A struct that contains a reference.
pub struct ContainsRef&lt;&#39;r&gt; {
  ref: &amp;&#39;r i64
}</code></pre>
<p><strong>English:</strong></p>
<div>
<ul>
<li class="fragment">Given an instance <code>let x: A = ...</code>, than
constraint <code>lifetime(x.ref) &gt;= lifetime(x)</code> must
hold.</li>
</ul>
</div>
</section>
<section id="lifetime-elision" class="slide level2">
<h2>Lifetime Elision</h2>
<p><strong>Question</strong>: ‚ÄúWhy haven‚Äôt I come across this
before?‚Äù</p>
<p><span class="fragment"><strong>Answer:</strong> ‚ÄúBecause of lifetime
elision!‚Äù</span></p>
</section>
<section id="lifetime-elision-1" class="slide level2">
<h2>Lifetime Elision</h2>
<p>Rust compiler has heuristics for eliding lifetime bounds:</p>
<div>
<ul>
<li class="fragment"><p>Each elided lifetime in input position becomes a
distinct lifetime parameter.</p>
<div class="columns">
<div class="column" style="width:40%;">
<pre class="rust code-no-margin"><code>fn print(a: &amp;str, b: &amp;str)</code></pre>
</div><div class="column" style="width:60%;">
<pre class="rust code-no-margin"><code>fn print(a: &amp;&#39;l1 str, b: &amp;&#39;l2 str)</code></pre>
</div>
</div></li>
<li class="fragment"><p>If <strong>exactly one</strong> input lifetime
position (elided or annotated), that lifetime is assigned to all elided
output lifetimes.</p>
<div class="columns">
<div class="column" style="width:40%;">
<pre class="rust code-no-margin"><code>fn print(a: &amp;str) -&gt; (&amp;str, &amp;str)</code></pre>
</div><div class="column" style="width:60%;">
<pre class="rust code-no-margin"><code>fn print(a: &amp;&#39;l1 str) -&gt; (&amp;&#39;l1 str, &amp;&#39;l1 str)</code></pre>
</div>
</div></li>
<li class="fragment"><p>If <strong>multiple</strong> input lifetime
positions, but one of them is <code>&amp;self</code> or
<code>&amp;mut self</code>, the lifetime of <code>self</code> is
assigned to all elided output lifetimes.</p>
<div class="columns">
<div class="column" style="width:40%;">
<pre class="rust code-no-margin"><code>fn print(&amp;self, a: &amp;str) -&gt; &amp;str</code></pre>
</div><div class="column" style="width:60%;">
<pre class="rust code-no-margin"><code>fn print(&amp;self: &amp;&#39;l1 str, a: &amp;&#39;l2 str) -&gt; &amp;&#39;l1 str</code></pre>
</div>
</div></li>
<li class="fragment"><p><strong>Otherwise</strong>, annotations are
needed to satisfy compiler.</p></li>
</ul>
</div>
<aside class="notes">
<ul>
<li>Rust is smart and tries to infer the lifetimes if it can do so.</li>
</ul>
</aside>
</section>
<section id="lifetime-elision-examples" class="slide level2">
<h2>Lifetime Elision Examples</h2>
<pre class="rust" data-line-numbers="all|1-2|4-5|7-8|10|12|14-15"><code>fn print(s: &amp;str);                                      // elided
fn print&lt;&#39;a&gt;(s: &amp;&#39;a str);                               // expanded

fn debug(lvl: usize, s: &amp;str);                          // elided
fn debug&lt;&#39;a&gt;(lvl: usize, s: &amp;&#39;a str);                   // expanded

fn substr(s: &amp;str, until: usize) -&gt; &amp;str;               // elided
fn substr&lt;&#39;a&gt;(s: &amp;&#39;a str, until: usize) -&gt; &amp;&#39;a str;     // expanded

fn get_str() -&gt; &amp;str;                                   // ILLEGAL (why?)

fn frob(s: &amp;str, t: &amp;str) -&gt; &amp;str;                      // ILLEGAL (why?)

fn get_mut(&amp;mut self) -&gt; &amp;mut T;                        // elided
fn get_mut&lt;&#39;a&gt;(&amp;&#39;a mut self) -&gt; &amp;&#39;a mut T;              // expanded</code></pre>
</section>
<section id="exercise-time" class="slide level2">
<h2>Exercise Time</h2>
<p>Approx. Time: 15-30 min.</p>
<p>Do the following exercises:</p>
<ul>
<li><code>lifetimes</code>: all</li>
</ul>
<p><strong>Build/Run/Test:</strong></p>
<pre class="bash"><code>just build &lt;exercise&gt; --bin 01
just run &lt;exercise&gt; --bin 01
just test &lt;exercise&gt; --bin 01
just watch [build|run|test|watch] &lt;exercise&gt; --bin 01</code></pre>
</section></section>
<section>
<section id="closures" class="title-slide slide level1">
<h1>Closures</h1>

</section>
<section id="closures-1" class="slide level2">
<h2>Closures</h2>
<pre class="rust"><code>fn main() {
    let z = 42;
    let compute = move |x, y| x + y + z; // Whats the type of this?

    let res = compute(1, 2);
}</code></pre>
<ul>
<li>Closures or lambda expressions are anonymous (unnamed)
functions.</li>
</ul>
<div>
<ul>
<li class="fragment">They can capture (‚Äúclose over‚Äù) values in their
scope.</li>
<li class="fragment">They are first-class values.</li>
<li class="fragment">They implement special traits: <code>Fn</code>,
<code>FnMut</code> and <code>FnOnce</code>.</li>
</ul>
</div>
<aside class="notes">
<ul>
<li>The <code>compute</code> closure captures <code>z</code> and we need
<code>move</code> in front to hand over the value <code>z</code> to the
closure which becomes its owner. :::</li>
</ul>
</aside>
</section>
<section id="what-is-a-closure" class="slide level2">
<h2>What is a Closure?</h2>
<p>The closure <code>|x: i32| x * x</code> can <em>mechanistically</em>
be mapped to the following <code>struct</code></p>
<pre class="rust" data-line-numbers="1"><code>struct SquareFunc {}

impl SquareFunc {
  fn call(&amp;self, x: i32) {
    x * x
  }
}</code></pre>
<p>‚ùóThe ‚Äústruct with fields‚Äù is a <strong>mental model</strong> how
<code>|x: i32| x * x</code> is <em>mechanistically</em> implemented by
the compiler.</p>
</section>
<section id="what-is-a-fn-closure" class="slide level2">
<h2>What is a <code>Fn</code> Closure?</h2>
<p>For a closure which captures (‚Äúcloses-over‚Äù) variables from the
environment:</p>
<pre class="rust" data-line-numbers="2"><code>let z = 43;
let square_it = |x| x * x + z;  // =&gt; Fn(i32) -&gt; i32     (LSP)
                                // compiler opaque type: approx `SquareIt`.
square_it(10);</code></pre>
<p>approx. maps to:</p>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" data-line-numbers="2"><code>struct SquareIt&lt;&#39;a&gt; {
  z: &amp;&#39;a i32;
}

impl SquareIt {
  fn call(&amp;self, x: i32) {
    x * x + self.z
  }
}</code></pre>
</div><div class="column" style="width:50%;">
<pre class="rust"><code>let z = 43;
let square_it = SquareIt{z: &amp;z};
square_it.call(10);</code></pre>
<p>‚ùóThe closure by default <strong>captures by reference</strong>.</p>
</div>
</div>
</section>
<section id="what-is-a-fnmut-closure" class="slide level2">
<h2>What is a <code>FnMut</code> Closure?</h2>
<p>A closure with some <strong>mutable state</strong>:</p>
<div class="columns">
<div class="column" style="width:60%;">
<pre class="rust" data-line-numbers="2,4,5"><code>fn main() {
  let mut total: i32 = 0;

  let mut square_it = |x| {
      // =&gt; FnMut(i32) -&gt; i32  (LSP)
      total += x * x;
      x * x
  };

  square_it(10);
  assert_eq!(100, total);
}</code></pre>
</div><div class="column" style="width:40%; align-content:center;">
<p>approx. maps to:</p>
<pre class="rust" data-line-numbers="6"><code>struct SquareIt&lt;&#39;a&gt;&#39; {
  total: &amp;&#39;a mut i32
}

impl SquareIt {
  fn call(&amp;mut self, x: i32) {
    self.total += x * x;
    x * x
  }
}</code></pre>
</div>
</div>
</section>
<section id="capture-by-value" class="slide level2">
<h2>Capture by Value</h2>
<p>Capture by value with <code>move</code>:</p>
<div class="columns">
<div class="column" style="width:60%;">
<pre class="rust" data-line-numbers="2,4" contenteditable="true"><code>fn main() {
  let mut total: i32 = 0; // Why `mut` here?

  let mut square_it = move |x| {
      // =&gt; FnMut(i32) -&gt; i32  (LSP)
      total += x * x;
      x + x
  };

  square_it(10);
  assert_eq!(0, total)
}</code></pre>
</div><div class="column" style="width:40%;">
<p>approx. maps to:</p>
<pre class="rust" data-line-numbers="2,6"><code>struct SquareIt {
  total: i32
}

impl SquareIt {
  fn call(&amp;mut self, x: i32) {
    self.total += x * x;
    x * x
  }
}</code></pre>
</div>
</div>
<aside class="notes">
<p>Without the <code>move</code> the snipped would not compile if you
add <code>total += 1</code> on L9 as you cannot capture immutable into
the closure and at the same time increment <code>z</code>.</p>
<p>You need <code>mut</code> because you cannot <code>move</code> from a
non <code>mut</code> value</p>
</aside>
</section>
<section id="example---quiz" class="slide level2">
<h2>Example - Quiz</h2>
<p>Does it compile? Does it run without panic?</p>
<pre class="rust" data-line-numbers="" contenteditable="true"><code>fn main() {
    let mut total: i32 = 0;

    let mut square_it = |x| { // =&gt; FnMut(i32) -&gt; i32
        total += x * x;
        x * x
    };
    total = -1;

    square_it(10);
    assert_eq!(-1, total)
}</code></pre>
<p><span class="fragment"><strong>Answer:</strong> It does not compile
as <code>total</code> is mut. borrowed on L8.<br> Move
<code>square_it</code> before <code>total = -1</code>.</span></p>
</section>
<section id="closure-traits" class="slide level2">
<h2>Closure Traits</h2>
<p><code>Fn</code>, <code>FnMut</code> and <code>FnOnce</code> are
traits which implement <strong>different behaviors</strong> for
<strong>closures</strong>. <em>The compiler implements the appropriate
ones!</em></p>
<img
data-src="presentations/part-1/assets/images/convert/22bdab0ff9c7708be438aa97ad32f5b6e09c35be.svg"
style="width:80%" />
<div class="columns">
<div class="column" style="width:50%;">
<div>
<div class="p-no-margin">
<ul>
<li class="fragment"><code>Fn</code>: closures that can be
<ul>
<li class="fragment">called multiple times
<strong>concurrently</strong></li>
<li class="fragment">borrowed immutable.</li>
</ul></li>
<li class="fragment"><code>FnMut</code>: closures that can be
<ul>
<li class="fragment">called multiple times <strong>not
concurrently</strong></li>
<li class="fragment">borrowed mutable.</li>
</ul></li>
<li class="fragment"><code>FnOnce</code>: closures that can be
<ul>
<li class="fragment">called once, it takes ownership of
<code>self</code>.</li>
</ul></li>
</ul>
</div>
</div>
</div><div class="column fragment" style="width:50%;">
<p>‚ùó<span class="emph">All closure implement <strong>at least</strong>
<code>FnOnce</code>.</span></p>
</div>
</div>
<aside class="notes">
<ul>
<li><p>The <code>Fn</code> trait represents closures that can be called
multiple times concurrently and can be borrowed immutably. This trait
has one associated method, <code>call(&amp;self, args)</code>, that
takes a borrowed reference to self, and it can be implemented by any
closure that meets these requirements.</p></li>
<li><p>The <code>FnMut</code> trait represents closures that can be
called multiple times and can be borrowed mutably. This trait has one
associated method, <code>call_mut(&amp;mut self, args)</code>, that
takes a mutable reference to the self, and it can be implemented by any
closure that meets these requirements.</p></li>
<li><p>The <code>FnOnce</code> trait represents closures that can be
called only once. This trait has one associated method,
<code>call_once(self, args)</code>, that takes ownership of self, and it
can be implemented by any closure that meets these
requirements.</p></li>
</ul>
</aside>
</section>
<section id="quiz---what-is-it" class="slide level2">
<h2>Quiz - What is it?</h2>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" contenteditable="true"><code>let mut s = String::from(&quot;foo&quot;);
let t     = String::from(&quot;bar&quot;);

let func = || {
    s += &amp;t;
    s
};</code></pre>
<p><strong>Question:</strong> Whats the type of <code>func</code>?</p>
</div><div class="column fragment" style="width:50%;">
<p><strong>Answer:</strong> Its only <code>FnOnce() -&gt; String</code>,
the compiler deduced that from the function body and return type.</p>
<p>The <em>mental model</em> is approx. this:</p>
<pre class="rust"><code>struct Closure&lt;&#39;a&gt; {
    s : String,
    t : &amp;&#39;a String,
}

impl&lt;&#39;a&gt; FnOnce&lt;()&gt; for Closure&lt;&#39;a&gt; {
    type Output = String;
    fn call_once(self) -&gt; String {
        self.s += &amp;*self.t;
        self.s
    }
}</code></pre>
</div>
</div>
</section>
<section id="closure-and-functional-programming" class="slide level2">
<h2>Closure and Functional Programming</h2>
<p>Useful when working with iterators, <code>Option</code> and
<code>Result</code>:</p>
<pre class="rust"><code>let numbers = vec![1, 3, 4, 10, 29];

let evens: Vec&lt;_&gt; = numbers.into_iter()
                           .filter(|x| x % 2 == 0)
                           .collect();</code></pre>
</section>
<section id="closures-and-functional-programming-2"
class="slide level2">
<h2>Closures and Functional Programming (2)</h2>
<p>Useful when generalizing interfaces, e.g.¬†<em>visitor
pattern</em></p>
<pre class="rust"><code>struct Graph{ nodes: Vec&lt;i32&gt;; };

impl Graph {

  fn visit(&amp;self, visitor: impl FnOnce(i32)) {
    // Remember: All closure at least implement `FnOnce`.
    for n in self.nodes {
      visitor(n) // Call visitor function for each node.
    }
  }

}</code></pre>
</section>
<section id="exercise-time-10" class="slide level2">
<h2>Exercise Time (10)</h2>
<p>Approx. Time: 20-60 min.</p>
<p>Do the following exercises:</p>
<ul>
<li><code>closures</code>: all</li>
</ul>
<p><strong>Build/Run/Test:</strong></p>
<pre class="bash"><code>just build &lt;exercise&gt; --bin 01
just run &lt;exercise&gt; --bin 01
just test &lt;exercise&gt; --bin 01
just watch [build|run|test|watch] &lt;exercise&gt; --bin 01</code></pre>
</section></section>
<section>
<section id="recap-2" class="title-slide slide level1">
<h1>Recap 2</h1>

</section>
<section id="recap-2---closures" class="slide level2">
<h2>Recap 2 - Closures</h2>
<pre class="rust"><code>fn main() {
    let numbers = vec![1, 2, 5, 9];
    let smaller_than_5 = |x: i32| -&gt; bool { x &lt; 5 };

    let res = filter(&amp;numbers, smaller_than_5);

    print!(&quot;Result: {res:?}&quot;)
}</code></pre>
<ul>
<li>Question: What is the type of <code>smaller_than_9</code>?</li>
<li>Question: How to write <code>filter</code> to be most generic.</li>
</ul>
<!-- markdownlint-disable-file MD034 MD033 MD001 MD024 MD026-->
</section></section>
<section>
<section id="trait-objects-dynamic-dispatch"
class="title-slide slide level1">
<h1>Trait Objects &amp; Dynamic Dispatch</h1>

</section>
<section id="trait-object" class="slide level2">
<h2>Trait‚Ä¶ Object?</h2>
<ul>
<li>We learned about <a href="#/traits-and-generics">traits</a>.</li>
<li>We learned about generics and <code>monomorphization</code>.</li>
</ul>
<p>There‚Äôs more to this story though‚Ä¶</p>
<p><strong>Question</strong>: What was monomorphization again?</p>
</section>
<section id="static-dispatch-monomorphization-recap"
class="slide level2">
<h2>Static Dispatch: Monomorphization (recap)</h2>
<p>The <a href="#/the-trait-keyword/1"><code>Add</code></a> trait.</p>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust"><code>impl Add for i32 {/* ... */}
impl Add for f32 {/* ... */}

fn add_values&lt;T: Add&gt;(l: &amp;T, r: &amp;T) -&gt; T
{
  l.add(r)
}

fn main() {
  let sum_one = add_values(&amp;6, &amp;8);
  let sum_two = add_values(&amp;6.5, &amp;7.5);
}</code></pre>
</div><div class="column" style="width:50%;">
<p>Code is <em>monomorphized</em>:</p>
<div>
<ul>
<li class="fragment">Two versions of <code>add_values</code> end up in
binary.</li>
<li class="fragment">Optimized separately and very fast to run (static
dispatch).</li>
<li class="fragment">Slow to compile and larger binary.</li>
</ul>
</div>
</div>
</div>
</section>
<section id="dynamic-dispatch" class="slide level2">
<h2>Dynamic Dispatch</h2>
<p><em>What if don‚Äôt know the concrete type implementing the trait at
compile time?</em></p>
<div class="columns">
<div class="column" style="width:48%;">
<pre class="rust" data-line-numbers="all|1-8|10-12"
style="font-size:14pt"><code>use std::io::Write;
use std::path::PathBuf;

struct FileLogger { log_file: PathBuf }
impl Write for FileLogger { /* ... */}

struct StdOutLogger;
impl Write for StdOutLogger { /* ... */}

fn log&lt;L: Write&gt;(logger: &amp;mut L, msg: &amp;str) {
  write!(logger, &quot;{}&quot;, msg);
}</code></pre>
</div><div class="column" style="width:50%;">
<pre class="rust" data-line-numbers="2|4-7|9"
style="font-size:14pt"><code>fn main() {
  let file: Option&lt;PathBuf&gt; = // args parsing...

  let mut logger = match file {
      Some(f) =&gt; FileLogger { log_file: f },
      None =&gt; StdOutLogger,
  };

  log(&amp;mut logger, &quot;Hello, world!ü¶Ä&quot;);
}</code></pre>
</div>
</div>
</section>
<section id="error" class="slide level2">
<h2>Error!</h2>
<pre class="txt"><code>error[E0308]: `match` arms have incompatible types
  --&gt; src/main.rs:19:17
   |
17 |       let mut logger = match log_file {
   |  ______________________-
18 | |         Some(log_file) =&gt; FileLogger { log_file },
   | |                           -----------------------
   | |                           this is found to be of
   | |                           type `FileLogger`
19 | |         None =&gt; StdOutLogger,
   | |                 ^^^^^^^^^^^^ expected struct `FileLogger`,
   | |                              found struct `StdOutLogger`
20 | |     };
   | |_____- `match` arms have incompatible types</code></pre>
<p><em>What‚Äôs the type of <code>logger</code>?</em></p>
</section>
<section id="heterogeneous-collections" class="slide level2">
<h2>Heterogeneous Collections</h2>
<p><em>What if we want to create collections of different types
implementing the same trait?</em></p>
<div class="columns">
<div class="column" style="width:45%;">
<pre class="rust" data-line-numbers="all|1-3|5-8,10-13"><code>trait Render {
  fn paint(&amp;self);
}

struct Circle;
impl Render for Circle {
  fn paint(&amp;self) { /* ... */ }
}

struct Rectangle;
impl Render for Rectangle {
  fn paint(&amp;self) { /* ... */ }
}</code></pre>
</div><div class="column fragment" style="width:55%;">
<pre class="rust" data-line-numbers="2-3|5-7,9-10"><code>fn main() {
  let circle = Circle{};
  let rect = Rectangle{};

  let mut shapes = Vec::new();
  shapes.push(circle);
  shapes.push(rect);

  shapes.iter()
        .for_each(|s| s.paint());
}</code></pre>
</div>
</div>
</section>
<section id="error-again" class="slide level2">
<h2>Error Again!</h2>
<pre class="txt"><code>   Compiling playground v0.0.1 (/playground)
error[E0308]: mismatched types
  --&gt; src/main.rs:20:17
   |
20 |     shapes.push(rect);
   |            ---- ^^^^ expected struct `Circle`,
   |                      found struct `Rectangle`
   |            |
   |            arguments to this method are incorrect
   |
note: associated function defined here
  --&gt; /rustc/2c8cc343237b8f7d5a3c3703e3a87f2eb2c54a74/library/alloc/src/vec/mod.rs:1836:12

For more information about this error, try `rustc --explain E0308`.
error: could not compile `playground` due to previous error</code></pre>
<p><em>What is the type of <code>shapes</code>?</em></p>
</section>
<section id="dynamically-sized-types-dst" class="slide level2">
<h2>Dynamically Sized Types (DST)</h2>
<p>Rust supports <strong>Dynamically Sized Types</strong> (DSTs): types
<strong>without a statically known size or alignment</strong>.</p>
<p>On the surface, <a
href="https://doc.rust-lang.org/nomicon/exotic-sizes.html"
target="_blank">this is a bit nonsensical</a>: <code>rustc</code> always
needs to know the size and alignment to compile code!</p>
<div>
<ul>
<li class="fragment"><p><a
href="https://doc.rust-lang.org/std/marker/trait.Sized.html"
target="_blank"><code>Sized</code></a> is a <strong>marker</strong>
trait for types with know-size at compile time.</p></li>
<li class="fragment"><p>Types in Rust can be <code>Sized</code> or
<code>!Sized</code> (unsized Ó™ú DSTs).</p></li>
</ul>
</div>
</section>
<section id="examples-of-sized-vs.-sized" class="slide level2">
<h2>Examples of <code>Sized</code> vs.¬†<code>!Sized</code></h2>
<div>
<ul>
<li class="fragment"><p>Most types are <code>Sized</code>, and
<strong>automatically</strong> marked as such</p>
<ul>
<li class="fragment"><code>i64</code></li>
<li class="fragment"><code>String</code></li>
<li class="fragment"><code>Vec&lt;String&gt;</code></li>
<li class="fragment">etc.</li>
</ul></li>
<li class="fragment"><p>Two major DSTs (<code>!Sized</code>) exposed by
the language (<strong>note the absence of a reference!</strong>):</p>
<ul>
<li class="fragment">Trait Objects: <code>dyn MyTrait</code> (covered in
the next section)</li>
<li class="fragment">Slices: <code>[T]</code>, <code>str</code>, and
others.</li>
</ul></li>
<li class="fragment"><p>DSTs can be <strong>only</strong> be used (local
variable) <strong>through a reference</strong>: <code>&amp;[T]</code>,
<code>&amp;str</code>, <code>&amp;dyn MyTrait</code> (references are
<code>Sized</code>).</p></li>
</ul>
</div>
<aside class="notes">
<p>Pointers, which essentially references (<code>&amp;str</code>) are,
always have a known size at compile, time that is why they can be stored
in local variables (which as you know live on the stack).</p>
</aside>
</section>
<section id="trait-objects-dyn-trait" class="slide level2">
<h2>Trait Objects <code>dyn Trait</code></h2>
<div>
<ul>
<li class="fragment"><p>Opaque type that implements a set of traits.</p>
<p>Type Description: <code>dyn MyTrait: !Sized</code></p></li>
<li class="fragment"><p>Like slices, trait objects <strong>always live
behind pointers</strong> (<code>&amp;dyn MyTrait</code>,
<code>&amp;mut dyn MyTrait</code>, <code>Box&lt;dyn MyTrait&gt;</code>,
<code>...</code>).</p></li>
<li class="fragment"><p>Concrete underlying types are erased from trait
object.</p></li>
</ul>
</div>
<pre class="rust fragment" data-line-numbers="5|6-8"><code>fn main() {
  let log_file: Option&lt;PathBuf&gt; = // ...

  // Create a trait object that implements `Write`
  let logger: &amp;mut dyn Write = match log_file {
    Some(log_file) =&gt; &amp;mut FileLogger { log_file },
    None =&gt; &amp;mut StdOutLogger,
  };
}</code></pre>
</section>
<section id="quiz---instantiate-a-trait" class="slide level2">
<h2>Quiz - Instantiate a Trait?</h2>
<pre class="rust" contenteditable="true"><code>struct A{}
trait MyTrait { fn show(&amp;self) {}; }
impl MyTrait for A {}

fn main() {
  let a: MyTrait = A{};
  let b: dyn MyTrait = A{};
}</code></pre>
<p><strong>Question:</strong> Does that compile?</p>
<div class="fragment">
<p><strong>Answer: No! - It‚Äôs invalid code.</strong></p>
<div>
<ul>
<li class="fragment">You can‚Äôt declare a local variable <code>a</code>,
<code>MyTrait</code> <strong>is not a type</strong>.</li>
<li class="fragment">You can‚Äôt declare <code>b</code> as
<code>dyn MyTrait</code>, because for the type system its
<code>!Sized</code> Ó™ú <strong>can‚Äôt compute size of memory of
<code>b</code> on the stack</strong>.</li>
<li class="fragment"><em>Also: You can‚Äôt pass the value of an unsized
type into a function as an argument or return it from a
function.</em></li>
</ul>
</div>
</div>
</section>
<section id="generics-and-sized-how" class="slide level2">
<h2>Generics and <code>Sized</code> : How?</h2>
<div>
<ul>
<li class="fragment"><p>Given a concrete type you can always say if its
<code>Sized</code> or <code>!Sized</code> (DST).</p></li>
<li class="fragment"><p>Whats with generics?</p></li>
</ul>
<pre class="rust fragment"><code>fn generic_fn&lt;T: Eq&gt;(x: T) -&gt; T { /*..*/ }</code></pre>
<ul>
<li class="fragment"><p>If <code>T</code> is <code>Sized</code>, all is
OK!.</p></li>
<li class="fragment"><p>If <code>T</code> is <code>!Sized</code>, then
the definition of <code>generic_fn</code> is incorrect! (why?)</p></li>
</ul>
</div>
<aside class="notes">
<p>It is incorrect because, you take a <code>T</code> which needs to be
constructed on the stack ergo have a fixed-size at compile time! You
also return a <code>T</code> which needs to have a fixed-size at compile
time (also on the stack frame).</p>
</aside>
</section>
<section id="generics-and-sized" class="slide level2">
<h2>Generics and <code>Sized</code></h2>
<ul>
<li><p>All <strong>generic type parameters</strong> are
<strong>implicitly</strong> <code>Sized</code> by default (everywhere
<code>structs</code>, <code>fn</code>s etc.):</p>
<p>For example:</p>
<pre class="rust fragment"><code>fn generic_fn&lt;T: Eq + Sized&gt;(x: T) -&gt; T { // Sized is obsolete here.
  //...
}</code></pre>
<p>or</p>
<pre class="rust fragment"><code>fn generic_fn&lt;T&gt;(x: &amp;T) -&gt; u32
where
    T: Eq + Sized // Sized is obsolete here.
{
  // ...
}</code></pre></li>
</ul>
</section>
<section id="generics-and-sized-1" class="slide level2">
<h2>Generics and <code>?Sized</code></h2>
<p>Sometimes we want to opt-out of <code>Sized</code>: use
<code>?Sized</code>:</p>
<pre class="rust"><code>fn generic_fn&lt;T: Eq + ?Sized&gt;(x: &amp;T) -&gt; u32 { ... }</code></pre>
<div>
<ul>
<li class="fragment"><p>In English: <code>?Sized</code> means
<code>T</code> also allows for dyn. sized types (DST) Ó™ú e.g.
<code>T := dyn Eq</code>.</p></li>
<li class="fragment"><p>So a <code>x: &amp;dyn Eq</code> is a reference
to a <strong>trait object</strong> which implements <a
href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"
target="_blank"><code>Eq</code></a>.</p></li>
</ul>
</div>
</section>
<section id="generics-and-sized---quiz" class="slide level2">
<h2>Generics and <code>?Sized</code> - Quiz</h2>
<p>Does that compile? Why?/Why not?</p>
<pre class="rust"><code>fn generic_fn&lt;T: Eq + ?Sized&gt;(x: &amp;T) -&gt; u32 { 42 }

fn main() {
  generic_fn(&quot;hello world&quot;)`
}</code></pre>
<div class="fragment">
<p><strong>Answer:</strong> <code>generic_fn</code> is instantiated with
<code>&amp;str</code>:</p>
<div>
<ul>
<li class="fragment">Ó™ú match <code>&amp;T &lt;-&gt; &amp;str</code></li>
<li class="fragment">Ó™ú <code>T := str</code></li>
<li class="fragment">Ó™ú <code>x: &amp;str</code> which is
<code>Sized</code></li>
<li class="fragment">Ó™ú ‚úÖ Yes it compiles.</li>
</ul>
</div>
</div>
</section>
<section id="generics-and-sized---quiz-1" class="slide level2">
<h2>Generics and <code>?Sized</code> - Quiz</h2>
<p>Does that compile? Why?/Why not?</p>
<pre class="rust" data-line-numbers=""><code>// removed the reference ------- v
fn generic_fn&lt;T: Eq + ?Sized&gt;(x: T) -&gt; u32 { 42 }

fn main() {
  generic_fn(&quot;hello world&quot;);
}</code></pre>
<div class="fragment">
<p><strong>Answer:</strong> ‚ùå No - declaration <code>generic_fn</code>
is invalid (line 5 is not the problem!):</p>
<div>
<ul>
<li class="fragment"><code>T</code> can <strong>potentially</strong> be
<code>dyn Eq</code> Ó™ú leads to <code>x: dyn Eq</code> which is not
<code>Sized</code> Ó™ú compile error.</li>
<li class="fragment"><span class="emph"><strong>Remember: function
parameter go onto the stack!</strong></span></li>
</ul>
</div>
</div>
<aside class="notes">
<p>The compile error has nothing to do with the call in 5!</p>
</aside>
</section>
<section id="generics-and-sized---quiz-tip" class="slide level2">
<h2>Generics and <code>?Sized</code> - Quiz (Tip)</h2>
<p>How to print the type <code>T</code>?</p>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust"><code>fn generic_fn&lt;T: Eq&gt;(x: T) -&gt; u32 {
    42
}

fn main() {
    generic_fn(&quot;hello world&quot;);
}</code></pre>
</div><div class="column fragment" style="width:50%;">
<pre class="rust"><code>fn generic_fn&lt;T: Eq + std::fmt::Display&gt;(x: T) -&gt; u32 {
    println!(
      &quot;x: {} = &#39;{x}&#39;&quot;,
      std::any::type_name::&lt;T&gt;());

    42
}

fn main() {
    generic_fn(&quot;hello world&quot;);
}</code></pre>
<pre><code>x: &amp;str = &#39;hello world&#39;</code></pre>
</div>
</div>
</section>
<section id="dynamic-dispatch-on-the-heap-idiomatic"
class="slide level2">
<h2>Dynamic Dispatch on the Heap (idiomatic)</h2>
<div class="columns">
<div class="column" style="width:55%;">
<pre class="rust" style="font-size:14pt;"><code>/// Same code as last slide
fn main() {
  let log_file: Option&lt;PathBuf&gt; = //...

  // Create a trait object on heap that impl. `Write`
  let logger: Box&lt;dyn Write&gt; = match log_file {
    Some(log_file) =&gt; Box::new(FileLogger{log_file}),
    None =&gt; Box::new(StdOutLogger),
  };

  log(&quot;Hello, world!ü¶Ä&quot;, &amp;mut logger);
}</code></pre>
</div><div class="column p-no-margin" style="width:45%;">
<p><img
data-src="presentations/part-1/assets/images/convert/presentations/part-1/assets/images/convert/c3bf504d8fd04a7b2792d18c01c5b446767b73fa.svg"
class="svgbob" /></p>
</div>
</div>
<div>
<ul>
<li class="fragment">üí∏ <strong>Cost</strong>: pointer indirection via
vtable (<strong>dynamic dispatch</strong>) Ó™ú less performant.</li>
<li class="fragment">üí∞ <strong>Benefit</strong>: no monomorphization
(no generics) Ó™ú smaller binary &amp; shorter compile time!</li>
<li class="fragment">üíª <strong>Memory</strong>: <code>logger</code> is
a smart-pointer where the data and vtable is on the
<strong>heap</strong> (dyn. mem. allocation Ó™ú üêå, <strong>this is fine
99% time</strong>)</li>
</ul>
</div>
<aside class="notes">
<p>A boxed dyn. Trait is totally fine and most of the time easier to
deal with in code. The dynamic memory allocation should not be your
premature optimization point! The pointer indirection is the same as in
the stack-based dynamic dispatch, do not think about this, it is 80%
premature optimization. Except if you are in a very hot loop where you
do dynamic dispatch always, then think about it, in all other cases
dont!.</p>
</aside>
</section>
<section id="dynamic-dispatch-on-the-stack-esoteric"
class="slide level2">
<h2>Dynamic Dispatch on the Stack (esoteric)</h2>
<div class="columns">
<div class="column" style="width:50%;">
<pre class="rust" style="font-size:14pt;"><code>/// Same code as last slide
fn main() {
  let log_file: Option&lt;PathBuf&gt; = //...

  // Create a trait object that implements `Write`
  let logger: &amp;mut dyn Write = match log_file {
    Some(log_file) =&gt; &amp;mut FileLogger{log_file},
    None =&gt; &amp;mut StdOutLogger,
  };

  log(&amp;mut logger, &quot;Hello World!&quot;);
}</code></pre>
</div><div class="column p-no-margin" style="width:50%;">
<p><img
data-src="presentations/part-1/assets/images/convert/presentations/part-1/assets/images/convert/d8eca80182b49b52785fd1799693e4e5ad2a0bc2.svg"
class="svgbob" /></p>
</div>
</div>
<div>
<ul>
<li class="fragment">üí∏ <strong>Cost</strong>: same as before.</li>
<li class="fragment">üí∞ <strong>Benefit</strong>: same as before.</li>
<li class="fragment">üíª <strong>Memory</strong>: <code>logger</code> is
a <strong>wide-pointer</strong> which lives <strong>only</strong> on the
<strong>stack</strong> Ó™ú üöÄ.</li>
</ul>
</div>
<aside class="notes">
<p>Its called wide-pointer because you have a pointer to data and a
pointer to the vtable with the functions. Do not think about the pointer
indirection, and less performant -&gt; this is 100% premature
optimization!</p>
</aside>
</section>
<section id="fixing-dynamic-logger" class="slide level2">
<h2>Fixing Dynamic Logger</h2>
<ul>
<li>Trait objects <code>&amp;dyn Trait</code>,
<code>Box&lt;dyn Trait&gt;</code>, ‚Ä¶ implement <code>Trait</code>!</li>
</ul>
<pre class="rust" data-line-numbers="all|9-13|1-4"><code>// L no longer must be `Sized`, so to accept trait objects.
fn log&lt;L: Write + ?Sized&gt;(entry: &amp;str, logger: &amp;mut L) {
    write!(logger, &quot;{}&quot;, entry);
}

fn main() {
    let log_file: Option&lt;PathBuf&gt; = // ...

    // Create a trait object that implements `Write`
    let logger: &amp;mut dyn Write = match log_file {
        Some(log_file) =&gt; &amp;mut FileLogger { log_file },
        None =&gt; &amp;mut StdOutLogger,
    };
    log(&quot;Hello, world!ü¶Ä&quot;, logger);
}</code></pre>
<p>And all is well! <a
href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=2f631621994c6a685ecad19c59704647"
target="_blank">Live Stack Dyn. Dispatch</a>, <a
href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=cf8fdfe6a4b6672a938db4834bc83ace"
target="_blank">Live Heap Dyn. Dispatch</a>.</p>
</section>
<section id="forcing-dynamic-dispatch" class="slide level2">
<h2>Forcing Dynamic Dispatch</h2>
<p>If one wants to enforce API users to use dynamic dispatch, use
<code>&amp;mut dyn Write</code> on <code>log</code>:</p>
<pre class="rust"><code>fn log(entry: &amp;str, logger: &amp;mut dyn Write) {
    write!(logger, &quot;{}&quot;, entry);
}

fn main() {
    let log_file: Option&lt;PathBuf&gt; = // ...

    // Create a trait object that implements `Write`
    let logger: &amp;mut dyn Write = match log_file {
        Some(log_file) =&gt; &amp;mut FileLogger { log_file },
        None =&gt; &amp;mut StdOutLogger,
    };

    log(&quot;Hello, world!ü¶Ä&quot;, &amp;mut logger);
}</code></pre>
</section>
<section id="heterogeneous-collection-on-the-heap" class="slide level2">
<h2>Heterogeneous Collection on the Heap</h2>
<div class="columns">
<div class="column" style="width:45%;">
<pre class="rust no-compile"><code>fn main() {
  let mut shapes = Vec::new();


  let circle = Circle;
  shapes.push(circle);

  let rect = Rectangle;
  shapes.push(rect);

  shapes.iter()
        .for_each(|s| s.paint());
}</code></pre>
</div><div class="column fragment" style="width:55%;">
<pre class="rust does-compile" data-line-numbers="2,3,5,8"><code>fn main() {
  let mut shapes: Vec&lt;Box&lt;dyn Render&gt;&gt;
    = Vec::new();

  let circle = Box::new(Circle);
  shapes.push(circle);

  let rect = Box::new(Rectangle);
  shapes.push(rect);

  shapes.iter()
        .for_each(|s| s.paint());
}</code></pre>
</div>
</div>
<p>All set!</p>
</section>
<section id="heterogeneous-collection-on-the-stack"
class="slide level2">
<h2>Heterogeneous Collection on the Stack üç≠</h2>
<pre class="rust"><code>fn main() {
    let shapes: [&amp;dyn Render; 2] = [&amp;Circle {}, &amp;Rectangle {}];
    shapes.iter().for_each(|shape| shape.paint());
}</code></pre>
<p>All set!</p>
</section>
<section id="trait-object-limitations" class="slide level2">
<h2>Trait Object Limitations</h2>
<ul>
<li><p>Pointer indirection cost.</p></li>
<li><p>Harder to debug.</p></li>
<li><p>Type erasure (you need a trait).</p></li>
<li><p>Not <strong>all traits</strong> work:</p>
<p><span class="emph"><strong>Traits need to be <em>dyn-compatible</em>
</strong></span></p></li>
</ul>
</section>
<section id="static-dispatch-or-dynamic-dispatch" class="slide level2">
<h2>Static Dispatch or Dynamic Dispatch?</h2>
<p>When to use what is rarely a clear-cut, but broadly</p>
<ul>
<li><p><strong>In libraries</strong>: use static dispatch for the user
to decide if they want to pass</p>
<ul>
<li>a <code>let d: &amp;dyn MyTrait</code> for a signature
<code>fn lib_func(s: impl MyTrait + ?Sized)</code>,</li>
<li>or a concrete type <code>A</code> which implements
<code>Trait</code>.</li>
</ul></li>
<li><p><strong>For binaries</strong>: you are writing final code Ó™ú use
dynamic dispatch (no generics) Ó™ú cleaner and faster compilable code with
only marginal performance cost.</p></li>
</ul>
</section>
<section id="static-dispatch-or-dynamic-dispatch-1"
class="slide level2">
<h2>Static Dispatch or Dynamic Dispatch?</h2>
<p>When to use what is rarely a clear-cut, but broadly</p>
<ul>
<li><p><strong>In libraries</strong>, use static dispatch for the user
to decide if they want to pass</p>
<ul>
<li>a <code>let d: &amp;dyn MyTrait</code> for a signature
<code>fn lib_func(s: impl MyTrait + ?Sized)</code>.</li>
<li>or a concrete type <code>A</code> which implements
<code>Trait</code>.</li>
</ul></li>
<li><p><strong>For binaries</strong>, you are writing final code, and
using dynamic dispatch (no generics) gives cleaner code, faster
compile.</p></li>
</ul>
</section>
<section id="dyn-compatible-trait" class="slide level2">
<h2><em>Dyn-Compatible</em> Trait</h2>
<p>A trait is <strong>dyn-compatible</strong> (formerly <em>object
safe</em>) when it fulfills:</p>
<ul>
<li>Trait <code>T</code> must not be <code>Sized</code>:
<em>Why?</em></li>
<li>If <code>trait T: Y</code>, then<code>Y</code> must be
dyn-compatible.</li>
<li>No associated constants allowed.</li>
<li>No associated types with generic allowed.</li>
<li>All associated functions must either be dispatchable from a trait
object, or explicitly non-dispatchable:
<ul>
<li>e.g.¬†function must have a receiver with a reference to
<code>Self</code></li>
</ul></li>
</ul>
<p>Details in <a
href="https://doc.rust-lang.org/beta/reference/items/traits.html#dyn-compatibility"
target="_blank">The Rust Reference</a>. Read them!</p>
<p>These seem to be compiler limitations.</p>
</section>
<section id="non-dyn-compatible-trait" class="slide level2">
<h2>Non <em>Dyn-Compatible</em> Trait (üò±)</h2>
<pre class="rust" data-line-numbers="1-4|6|8-13|16-19"><code>trait Fruit {
  fn create(&amp;self) -&gt; Self;
  fn show(&amp;self) -&gt; String;
}

struct Banana { color: i32 }

impl Fruit for Banana {
  fn create(&amp;self) -&gt; Self { Banana {} }

  fn show(&amp;self) -&gt; String {
      return format!(&quot;banana: color {}&quot;, self.color).to_string();
  }
}

fn main() {
    let obj: Box&lt;dyn Fruit&gt; = Box::new(Banana { color: 10 });
    println!(&quot;type: {}&quot;, obj.show())
}</code></pre>
</section>
<section id="non-dyn-compatible-trait-1" class="slide level2">
<h2>Non <em>Dyn-Compatible</em> Trait (üí©)</h2>
<pre class="text"><code>error[E0038]: the trait `Fruit` cannot be made into an object

18 |     println!(&quot;type: {}&quot;, obj.show())
   |                          ^^^^^^^^^^ `Fruit` cannot be made into an object

note: for a trait to be &quot;dyn-compatible&quot; it needs to
      allow building a vtable to allow the call to be
      resolvable dynamically; for more information
      visit &lt;https://doc.rust-lang.org/beta/reference/items/traits.html#dyn-compatibility&gt;

1  | trait Fruit {
   |       ----- this trait cannot be made into an object...
2  |   fn create(&amp;self) -&gt; Self;
   |                       ^^^^ ...because method `create` references
                                the `Self` type in its return type</code></pre>
</section>
<section id="trait-object-summary" class="slide level2">
<h2>Trait Object Summary</h2>
<ul>
<li>Trait objects allow for dynamic dispatch and heterogeneous
containers.</li>
<li>Trait objects introduce pointer indirection.</li>
<li>Traits need to be <em>dyn-compatible</em> to make trait objects out
of them.</li>
</ul>
</section></section>
    </div>
  </div>

  <script src="plugin/code-blocks/move-data-attributes.js"></script>
  <script src="plugin/highlight/add-keywords.js"></script>

  <script src="dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script src="plugin/math/math.js"></script>
  <script src="plugin/search/search.js"></script>
  <script src="plugin/zoom/zoom.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/menu/menu.js"></script>

  <script>
      moveDataAttributesToCodeElement()

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'fade',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1200,

        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 5.0e-2,

        // Bounds for smallest/largest possible scale to apply to content
        minScale: 0.1,

        maxScale: 2,
        mathjax3: {
          mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg-full.js',
          tex: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
          },
        },

        // Reveal Menu Plugin:
        // https://github.com/denehyg/reveal.js-menu/tree/2.1.0?tab=readme-ov-file
        menu: {
            // Specifies which side of the presentation the menu will
            // be shown. Use 'left' or 'right'.
            side: 'left',

            // Specifies the width of the menu.
            // Can be one of the following:
            // 'normal', 'wide', 'third', 'half', 'full', or
            // any valid css length value
            width: 'normal',

            // Add slide numbers to the titles in the slide list.
            // Use 'true' or format string (same as reveal.js slide numbers)
            numbers: false,

            // Specifies which slide elements will be used for generating
            // the slide titles in the menu. The default selects the first
            // heading element found in the slide, but you can specify any
            // valid css selector and the text from the first matching
            // element will be used.
            // Note: that a section data-menu-title attribute or an element
            // with a menu-title class will take precedence over this option
            titleSelector: 'h1, h2, h3, h4, h5, h6',

            // If slides do not have a matching title, attempt to use the
            // start of the text content as the title instead
            useTextContentForMissingTitles: false,

            // Hide slides from the menu that do not have a title.
            // Set to 'true' to only list slides with titles.
            hideMissingTitles: false,

            // Adds markers to the slide titles to indicate the
            // progress through the presentation. Set to 'false'
            // to hide the markers.
            markers: true,

            // Specify custom panels to be included in the menu, by
            // providing an array of objects with 'title', 'icon'
            // properties, and either a 'src' or 'content' property.
            custom: false,

            // Specifies the themes that will be available in the themes
            // menu panel. Set to 'true' to show the themes menu panel
            // with the default themes list. Alternatively, provide an
            // array to specify the themes to make available in the
            // themes menu panel, for example...
            //
            // [
            //     { name: 'Black', theme: 'dist/theme/black.css' },
            //     { name: 'White', theme: 'dist/theme/white.css' },
            //     { name: 'League', theme: 'dist/theme/league.css' },
            //     {
            //       name: 'Dark',
            //       theme: 'lib/reveal.js/dist/theme/black.css',
            //       highlightTheme: 'lib/reveal.js/plugin/highlight/monokai.css'
            //     },
            //     {
            //       name: 'Code: Zenburn',
            //       highlightTheme: 'lib/reveal.js/plugin/highlight/zenburn.css'
            //     }
            // ]
            //
            // Note: specifying highlightTheme without a theme will
            // change the code highlight theme while leaving the
            // presentation theme unchanged.
            themes: false,

            // Specifies the path to the default theme files. If your
            // presentation uses a different path to the standard reveal
            // layout then you need to provide this option, but only
            // when 'themes' is set to 'true'. If you provide your own
            // list of themes or 'themes' is set to 'false' the
            // 'themesPath' option is ignored.
            themesPath: 'dist/theme/',

            // Specifies if the transitions menu panel will be shown.
            // Set to 'true' to show the transitions menu panel with
            // the default transitions list. Alternatively, provide an
            // array to specify the transitions to make available in
            // the transitions panel, for example...
            // ['None', 'Fade', 'Slide']
            transitions: false,

            // Adds a menu button to the slides to open the menu panel.
            // Set to 'false' to hide the button.
            openButton: true,

            // If 'true' allows the slide number in the presentation to
            // open the menu panel. The reveal.js slideNumber option must
            // be displayed for this to take effect
            openSlideNumber: false,

            // If true allows the user to open and navigate the menu using
            // the keyboard. Standard keyboard interaction with reveal
            // will be disabled while the menu is open.
            keyboard: true,

            // Normally the menu will close on user actions such as
            // selecting a menu item, or clicking the presentation area.
            // If 'true', the sticky option will leave the menu open
            // until it is explicitly closed, that is, using the close
            // button or pressing the ESC or m key (when the keyboard
            // interaction option is enabled).
            sticky: false,

            // If 'true' standard menu items will be automatically opened
            // when navigating using the keyboard. Note: this only takes
            // effect when both the 'keyboard' and 'sticky' options are enabled.
            autoOpen: true,

            // If 'true' the menu will not be created until it is explicitly
            // requested by calling RevealMenu.init(). Note this will delay
            // the creation of all menu panels, including custom panels, and
            // the menu button.
            delayInit: false,

            // If 'true' the menu will be shown when the menu is initialised.
            openOnInit: false,

            // By default the menu will load it's own font-awesome library
            // icons. If your presentation needs to load a different
            // font-awesome library the 'loadIcons' option can be set to false
            // and the menu will not attempt to load the font-awesome library.
            loadIcons: true
        },

        highlight: {
          highlightOnLoad: false,
          beforeHighlight: (hljs) => {
            const keywords = new Map([
              [ "bash", [ "cargo","rustc" ] ]
            ]);
            addHighlightJSKeywords(hljs, keywords)

            // Run the plugin's highlighting code that was skipped on load
            Array.from(Reveal.getRevealElement().querySelectorAll('pre code')).forEach((block) => {
                RevealHighlight().highlightBlock(block);
            });
          }
        },

        // reveal.js plugins
        plugins: [
          RevealNotes,
          RevealSearch,
          RevealZoom,
          RevealHighlight,
          RevealMath.MathJax3,
          RevealMenu
        ]
      });
    </script>
    </body>
</html>
